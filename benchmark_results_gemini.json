{
  "summary": {
    "passed": 6,
    "failed": 44,
    "errors": 0
  },
  "results": [
    {
      "overall_status": "pass",
      "overall_score": 100,
      "summary": "O código está em conformidade com todas as regras de validação estabelecidas.",
      "violations": [],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Define response_model",
            "Especifica status_code explicitamente",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Função possui return type annotation",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 15.14,
        "timestamp": "2026-01-15 23:32:47"
      },
      "file_path": "[EXCELLENT] EXC_001"
    },
    {
      "overall_status": "pass",
      "overall_score": 100,
      "summary": "O código está bem estruturado e segue todas as boas práticas de FastAPI.",
      "violations": [],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Define response_model",
            "Especifica status_code explicitamente",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Função possui return type annotation",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 16.35,
        "timestamp": "2026-01-15 23:33:03"
      },
      "file_path": "[EXCELLENT] EXC_002"
    },
    {
      "overall_status": "pass",
      "overall_score": 100,
      "summary": "O código segue todas as boas práticas e regras de validação especificadas.",
      "violations": [],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Define response_model",
            "Especifica status_code explicitamente",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Função possui return type annotation",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 8.91,
        "timestamp": "2026-01-15 23:33:12"
      },
      "file_path": "[EXCELLENT] EXC_003"
    },
    {
      "overall_status": "pass",
      "overall_score": 100,
      "summary": "O código adere a todas as regras de validação especificadas, demonstrando alta qualidade estrutural e conformidade com boas práticas.",
      "violations": [],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Define response_model",
            "Especifica status_code explicitamente",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Função possui return type annotation",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 17.39,
        "timestamp": "2026-01-15 23:33:29"
      },
      "file_path": "[EXCELLENT] EXC_004"
    },
    {
      "overall_status": "fail",
      "overall_score": 40,
      "summary": "O código possui problemas na estrutura do endpoint, anotações de tipo e tratamento de erros para operações críticas em background.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint não define um 'response_model' para a resposta de sucesso. Isso impede que a documentação OpenAPI exiba o schema da resposta esperada de forma precisa.",
          "suggestion": "Defina um Pydantic 'response_model' para o endpoint. Por exemplo, crie uma classe `MessageResponse(BaseModel): message: str` e adicione `response_model=MessageResponse` ao decorador `@router.post`.",
          "line_reference": "Linha 16"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função `send_email_background` não possui uma anotação de tipo de retorno explícita. Embora retorne 'None' implicitamente, é uma boa prática declará-lo para clareza e análise estática de código.",
          "suggestion": "Adicione '-> None' à assinatura da função: `def send_email_background(email: str, content: str) -> None:`",
          "line_reference": "Linha 11"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Possui try-except para operações críticas",
          "description": "A função `send_email_background` simula uma operação crítica (envio de email) mas não possui tratamento de erros (`try-except`). Falhas que ocorram durante o envio real do email não seriam capturadas nem logadas, podendo levar a tarefas em background silenciosamente falhas.",
          "suggestion": "Implemente um bloco `try-except` dentro de `send_email_background` para lidar com exceções (ex: falha de rede, servidor SMTP indisponível) e adicione logging adequado para monitoramento.",
          "line_reference": "Linha 13"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Especifica status_code explicitamente",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 22.44,
        "timestamp": "2026-01-15 23:33:52"
      },
      "file_path": "[EXCELLENT] EXC_005"
    },
    {
      "overall_status": "fail",
      "overall_score": 95,
      "summary": "Código possui um problema de tratamento de erro crítico em operação de I/O.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Possui try-except para operações críticas",
          "description": "A operação de leitura de arquivo (await file.read()) é uma operação I/O crítica que pode falhar e não está envolvida em um bloco try-except para tratamento de exceções.",
          "suggestion": "Encapsule a chamada 'await file.read()' dentro de um bloco try-except para lidar com possíveis falhas de I/O, retornando uma HTTPException apropriada (ex: status.HTTP_500_INTERNAL_SERVER_ERROR).",
          "line_reference": "Linha 33"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Define response_model",
            "Especifica status_code explicitamente",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Função possui return type annotation",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 16.21,
        "timestamp": "2026-01-15 23:34:08"
      },
      "file_path": "[EXCELLENT] EXC_006"
    },
    {
      "overall_status": "fail",
      "overall_score": 79,
      "summary": "O código possui problemas críticos no tratamento de erros e na estrutura explícita do endpoint.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint GET '/search' não especifica explicitamente o status_code de sucesso (ex: 200 OK). Embora 200 seja o padrão para GET, a regra exige clareza explícita para padronização e documentação.",
          "suggestion": "Adicione 'status_code=200' ao decorador @router.get() para maior clareza e aderência à API. Ex: `@router.get('/search', response_model=List[ItemResponse], status_code=200, tags=['items'])`",
          "line_reference": "Linha 23"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Possui try-except para operações críticas",
          "description": "As operações de banco de dados (db.query, query.filter, query.all) são críticas e podem falhar devido a problemas de conexão, dados ou servidor. Não há um bloco try-except para lidar com exceções de forma graciosa, o que pode resultar em erros 500 genéricos para o cliente.",
          "suggestion": "Encapsule as operações de banco de dados em um bloco try-except para capturar e tratar exceções específicas (ex: OperationalError, SQLAlchemyError), retornando um HTTPException apropriado.",
          "line_reference": "Linha 32"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Usa HTTPException apropriadamente",
          "description": "Em caso de falha nas operações críticas (ex: banco de dados), o endpoint retornaria um erro 500 sem detalhes úteis para o cliente. Não há uso de HTTPException para retornar erros padronizados da API com mensagens claras e status codes apropriados.",
          "suggestion": "Dentro do bloco 'except', levante HTTPException com um status_code e 'detail' apropriados (ex: `raise HTTPException(status_code=500, detail='Erro interno do servidor ao buscar itens')`) para informar o cliente sobre o problema.",
          "line_reference": "Linha 32"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Define status codes corretos para erros",
          "description": "Não há definição explícita de status codes HTTP para cenários de erro esperados ou inesperados que possam surgir das operações de banco de dados ou lógica de negócio (ex: 404 Not Found, 400 Bad Request, 500 Internal Server Error).",
          "suggestion": "Ao levantar HTTPException, certifique-se de usar os status codes HTTP semânticos corretos para cada tipo de erro, melhorando a comunicação com os clientes da API. Considere adicionar `@router.get(..., responses={500: {'description': 'Erro interno do servidor'}})` ao decorador.",
          "line_reference": "Linha 32"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Define response_model",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Função possui return type annotation",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 22.68,
        "timestamp": "2026-01-15 23:34:31"
      },
      "file_path": "[EXCELLENT] EXC_007"
    },
    {
      "overall_status": "fail",
      "overall_score": 83,
      "summary": "Código possui problemas de estrutura e type hints, e sugestões para melhorias na validação de entrada.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint `delete_user_admin` não define `response_model` explicitamente. Embora o status 204 NO CONTENT não retorne corpo, documentar a ausência de um modelo de resposta ou um modelo de erro é uma boa prática para clareza e ferramentas de documentação.",
          "suggestion": "Adicione `response_model=None` ou um modelo Pydantic vazio, ou um modelo de erro para status 4xx, no decorador `@router.delete`.",
          "line_reference": "Linha 11"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função de dependência `get_current_user` não possui uma anotação de tipo de retorno. Isso dificulta a compreensão do que a função retorna, especialmente importante em funções que validam e retornam um objeto de usuário.",
          "suggestion": "Adicione `-> User` ou `-> Optional[User]` (ou o tipo correto que a função retorna em caso de sucesso) à assinatura da função `get_current_user`.",
          "line_reference": "Linha 7"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Usa Query(), Path(), Body() para documentação",
          "description": "O parâmetro de path `user_id` não usa `Path()` explicitamente para documentação e validações adicionais. Embora FastAPI infira que é um Path, o uso explícito melhora a documentação OpenAPI e permite a adição de validações complexas.",
          "suggestion": "Modifique `user_id: int` para `user_id: int = Path(..., description='ID do usuário a ser removido', gt=0)` para melhor documentação e validação de valor positivo.",
          "line_reference": "Linha 17"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Especifica status_code explicitamente",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 28.33,
        "timestamp": "2026-01-15 23:34:59"
      },
      "file_path": "[EXCELLENT] EXC_008"
    },
    {
      "overall_status": "fail",
      "overall_score": 55,
      "summary": "Código possui problemas críticos de tratamento de erros e uso inadequado de async/await.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Usa HTTPException apropriadamente",
          "description": "A função retorna um status HTTP 200 OK (definido no decorator) mesmo quando ocorre uma exceção na conexão com o banco de dados. Isso pode enganar clientes sobre o real estado do serviço, que deveria ser um erro de servidor (HTTP 500).",
          "suggestion": "Em caso de falha na conexão com o banco de dados, levante uma `HTTPException` com `status.HTTP_500_INTERNAL_SERVER_ERROR` e uma mensagem detalhada, ao invés de retornar um JSON com status 200.",
          "line_reference": "Linha 18"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Define status codes corretos para erros",
          "description": "O endpoint está configurado para retornar `status.HTTP_200_OK` em todos os cenários, incluindo falhas na conexão com o banco de dados. Não há um status code HTTP apropriado (ex: 500) definido para o erro, apenas um status textual no corpo da resposta.",
          "suggestion": "Utilize `raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail='Database connection error')` dentro do bloco `except` para sinalizar corretamente o erro HTTP.",
          "line_reference": "Linha 18"
        },
        {
          "severity": "info",
          "rule_category": "async_usage",
          "check_failed": "Preferência por funções async quando possível",
          "description": "A função é declarada `async def`, mas a operação de banco de dados `db.execute(text('SELECT 1'))` é uma chamada bloqueante síncrona de SQLAlchemy. Isso irá bloquear o loop de eventos, anulando os benefícios de uma função assíncrona.",
          "suggestion": "Para operações de banco de dados bloqueantes em funções `async`, use `await asyncio.to_thread(db.execute, text('SELECT 1'))` para executá-las em um thread pool separado (importando `asyncio`). Alternativamente, utilize um driver/ORM de banco de dados assíncrono, como SQLAlchemy com `asyncio` e `asyncpg` para chamadas `await db.execute(...)` verdadeiramente não bloqueantes.",
          "line_reference": "Linha 15"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Define response_model",
            "Especifica status_code explicitamente",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Função possui return type annotation",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        }
      ],
      "_metadata": {
        "response_time": 20.99,
        "timestamp": "2026-01-15 23:35:20"
      },
      "file_path": "[EXCELLENT] EXC_009"
    },
    {
      "overall_status": "fail",
      "overall_score": 95,
      "summary": "Código possui uma violação estrutural em um endpoint, mas adere bem a outras boas práticas de FastAPI e Python.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint que retorna 'StreamingResponse' não define um 'response_model' ou o parâmetro 'responses' para documentar explicitamente o tipo e a estrutura da resposta no OpenAPI. Embora 'StreamingResponse' não seja um modelo Pydantic para JSON, a ausência desta definição resulta em uma documentação menos informativa no Swagger UI.",
          "suggestion": "Considere adicionar 'response_model=Response' (importando 'Response' de 'fastapi') para indicar um tipo de resposta HTTP genérico, ou utilize o parâmetro 'responses' para fornecer uma descrição mais detalhada do conteúdo do stream (e.g., media_type, schema, exemplos).",
          "line_reference": "Linha 9"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Especifica status_code explicitamente",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Função possui return type annotation",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 21.05,
        "timestamp": "2026-01-15 23:35:41"
      },
      "file_path": "[EXCELLENT] EXC_010"
    },
    {
      "overall_status": "fail",
      "overall_score": 60,
      "summary": "Código apresenta problemas de estrutura de endpoint e tipagem.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint não declara a propriedade 'tags'. Isso dificulta a organização e descoberta na documentação Swagger UI, especialmente em projetos maiores com muitos endpoints.",
          "suggestion": "Adicione a propriedade `tags=['NomeDaRota']` ou `tags=['items']` ao decorador `@router.get` para melhor categorização.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Usa tipos adequados (List, Dict, Optional, etc)",
          "description": "O tipo `List` é usado no `response_model` e na anotação de retorno da função, mas não foi importado do módulo `typing`. Isso causará um `NameError` em tempo de execução.",
          "suggestion": "Importe `List` do módulo `typing` adicionando `from typing import List` no início do arquivo.",
          "line_reference": "Linha 7, 11"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Define response_model",
            "Especifica status_code explicitamente",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Função possui return type annotation"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 17.42,
        "timestamp": "2026-01-15 23:35:59"
      },
      "file_path": "[GOOD] GOOD_001"
    },
    {
      "overall_status": "fail",
      "overall_score": 70,
      "summary": "Código possui um tratamento de erro genérico que pode mascarar problemas.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Usa HTTPException apropriadamente",
          "description": "O bloco `except Exception as e:` captura todas as exceções, o que é uma má prática pois pode mascarar erros inesperados e dificultar a depuração. As operações de banco de dados podem falhar de maneiras mais específicas que deveriam ser tratadas individualmente.",
          "suggestion": "Capture exceções mais específicas do banco de dados (ex: `SQLAlchemyError` se usando SQLAlchemy) ou permita que exceções não tratadas sejam propagadas para o FastAPI, que as tratará como 500 Internal Server Error por padrão. Evite `except Exception` genérico. Se for necessário um tratamento genérico global, utilize um middleware de tratamento de exceções.",
          "line_reference": "Linha 17"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Define response_model",
            "Especifica status_code explicitamente",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Função possui return type annotation",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 19.21,
        "timestamp": "2026-01-15 23:36:18"
      },
      "file_path": "[GOOD] GOOD_002"
    },
    {
      "overall_status": "warning",
      "overall_score": 88,
      "summary": "O código é funcional, mas possui oportunidades de melhoria em documentação de parâmetros e uso eficaz de assincronicidade.",
      "violations": [
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Usa Query(), Path(), Body() para documentação",
          "description": "Os parâmetros 'skip' e 'limit' são definidos com valores padrão mas não utilizam explicitamente `Query()` para fornecer documentação detalhada no OpenAPI/Swagger UI.",
          "suggestion": "Utilize `Query()` para documentar e validar parâmetros de query, por exemplo: `skip: int = Query(0, description='Número de itens a pular')`.",
          "line_reference": "Linhas 12-13"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Define validações quando necessário",
          "description": "Validações importantes como `ge=0` (maior ou igual a zero) para 'skip' e 'limit' não foram explicitamente definidas, o que pode levar a entradas inválidas sem um erro claro.",
          "suggestion": "Adicione validações aos parâmetros `skip` e `limit` usando `Query()`, por exemplo: `skip: int = Query(0, ge=0)` e `limit: int = Query(100, ge=1, le=100)`.",
          "line_reference": "Linhas 12-13"
        },
        {
          "severity": "info",
          "rule_category": "async_usage",
          "check_failed": "Preferência por funções async quando possível",
          "description": "A função é declarada como `async`, mas a operação de banco de dados `db.query().all()` é síncrona. Executar operações de I/O bloqueantes diretamente em uma função `async` bloqueia o loop de eventos, anulando os benefícios da programação assíncrona.",
          "suggestion": "Para operações de I/O bloqueantes em funções `async`, use `await asyncio.to_thread(sua_funcao_bloqueante)` para executá-las em um thread pool separado, ou utilize uma versão assíncrona do SQLAlchemy (como `SQLAlchemy-Asyncio`) ou outro driver assíncrono para o banco de dados.",
          "line_reference": "Linha 21"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Define response_model",
            "Especifica status_code explicitamente",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Função possui return type annotation",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        }
      ],
      "_metadata": {
        "response_time": 20.92,
        "timestamp": "2026-01-15 23:36:39"
      },
      "file_path": "[GOOD] GOOD_003"
    },
    {
      "overall_status": "fail",
      "overall_score": 74,
      "summary": "O endpoint possui problemas na estrutura da API e nas anotações de tipo.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint '/search' não define um 'response_model'. Isso impede a documentação automática precisa do esquema de resposta e a validação do tipo de saída.",
          "suggestion": "Defina um modelo Pydantic para a resposta esperada (ex: 'class SearchResponse(BaseModel): query: str') e use-o em 'response_model=SearchResponse'.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint '/search' não especifica um 'status_code' explicitamente. Embora 200 seja o padrão, explicitá-lo melhora a clareza e legibilidade do código.",
          "suggestion": "Adicione 'status_code=200' ao decorador '@router.get()'.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint '/search' não possui 'tags' definidas. Tags são essenciais para organizar a documentação Swagger/OpenAPI e agrupar endpoints relacionados.",
          "suggestion": "Adicione 'tags=['Search']' (ou uma tag apropriada) ao decorador '@router.get()'.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função 'search' não declara o tipo de retorno. Isso prejudica a legibilidade e a análise estática de código.",
          "suggestion": "Adicione '-> dict' (ou um modelo Pydantic adequado) à assinatura da função: 'async def search(...) -> dict:'.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Usa tipos adequados (List, Dict, Optional, etc)",
          "description": "O parâmetro 'q' é anotado como 'str', mas 'Query(None)' indica que ele pode ser opcional (None). O tipo correto deveria ser 'Optional[str]'.",
          "suggestion": "Altere a anotação de tipo para 'q: Optional[str]'.",
          "line_reference": "Linha 6"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Usa APIRouter ao invés de FastAPI app",
            "Possui docstring explicativa"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 16.11,
        "timestamp": "2026-01-15 23:36:55"
      },
      "file_path": "[GOOD] GOOD_004"
    },
    {
      "overall_status": "pass",
      "overall_score": 100,
      "summary": "Código FastAPI bem estruturado e segue todas as boas práticas definidas.",
      "violations": [],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Define response_model",
            "Especifica status_code explicitamente",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Função possui return type annotation",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 10.66,
        "timestamp": "2026-01-15 23:37:05"
      },
      "file_path": "[GOOD] GOOD_005"
    },
    {
      "overall_status": "fail",
      "overall_score": 68,
      "summary": "Código possui problemas significativos de estrutura, tipagem e tratamento de erros para um endpoint de autenticação.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "A função do endpoint 'login' não possui uma docstring explicando sua funcionalidade, parâmetros e retorno. Isso prejudica a documentação automática do Swagger/OpenAPI e a legibilidade do código.",
          "suggestion": "Adicione uma docstring à função 'login' (ex: '''Autentica um usuário e retorna um token JWT.''')",
          "line_reference": "Linha 10"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint 'login' não define um `response_model` para especificar a estrutura do retorno esperado. Isso impede que o FastAPI gere a documentação correta para a resposta e não valida o tipo de saída.",
          "suggestion": "Defina um Pydantic `response_model` para o retorno da função e adicione-o ao decorador `@router.post(response_model=SeuModeloDeRetorno)`.",
          "line_reference": "Linha 10"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função 'login' não possui uma anotação de tipo para o seu valor de retorno. Isso dificulta a análise estática e o entendimento do tipo de dado que a função produz.",
          "suggestion": "Adicione uma anotação de tipo ao retorno da função (ex: `-> dict[str, str]`). Idealmente, use um Pydantic model para o retorno.",
          "line_reference": "Linha 10"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Possui try-except para operações críticas",
          "description": "A lógica de autenticação (implícita no comentário) em 'login' pode envolver operações críticas como acesso a banco de dados ou verificação de credenciais, que podem falhar. Não há tratamento de exceções com `try-except`.",
          "suggestion": "Implemente blocos `try-except` para capturar exceções durante operações críticas de login e lidar com elas de forma graciosa, retornando respostas de erro apropriadas.",
          "line_reference": "Linha 12"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Usa HTTPException apropriadamente",
          "description": "O endpoint 'login' não usa `HTTPException` para sinalizar falhas de autenticação ou outros erros. Retornar apenas um status 200 para todos os casos não é adequado para cenários de erro.",
          "suggestion": "Utilize `raise HTTPException(status_code=..., detail=...)` dentro do bloco `try-except` para indicar falhas de autenticação (e.g., 401 Unauthorized) ou outros problemas.",
          "line_reference": "Linha 12"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Define status codes corretos para erros",
          "description": "A função 'login' atualmente retorna um status 200 OK em todas as situações. Em caso de falha de autenticação ou outros erros, um status code mais apropriado (e.g., 401 Unauthorized, 400 Bad Request) deveria ser retornado.",
          "suggestion": "Ao usar `HTTPException`, certifique-se de definir `status_code`s HTTP apropriados para diferentes cenários de erro (e.g., `status.HTTP_401_UNAUTHORIZED` para credenciais inválidas).",
          "line_reference": "Linha 12"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Especifica status_code explicitamente",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 24.6,
        "timestamp": "2026-01-15 23:37:30"
      },
      "file_path": "[GOOD] GOOD_006"
    },
    {
      "overall_status": "fail",
      "overall_score": 60,
      "summary": "Código possui problemas de tipagem e documentação de endpoint.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint '/debug' não define um 'response_model', o que impede a geração de documentação de API precisa e validação de saída automática pelo FastAPI.",
          "suggestion": "Crie um Pydantic model (ex: DebugResponse(BaseModel): status: str) e defina-o no decorador: `@router.get('/debug', response_model=DebugResponse, ...)`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função 'debug_endpoint' não possui uma anotação de tipo de retorno explícita. Isso dificulta a leitura, a manutenção do código e a análise estática por ferramentas.",
          "suggestion": "Adicione a anotação de tipo de retorno à função, por exemplo, `async def debug_endpoint() -> Dict[str, str]:`.",
          "line_reference": "Linha 6"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Especifica status_code explicitamente",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 18.88,
        "timestamp": "2026-01-15 23:37:49"
      },
      "file_path": "[GOOD] GOOD_007"
    },
    {
      "overall_status": "fail",
      "overall_score": 79,
      "summary": "O código possui problemas de estrutura de endpoint, convenções de nomenclatura e tipagem de retorno.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint não define um 'response_model' explícito. Isso impede a validação automática da saída e a geração de documentação precisa para o esquema de resposta.",
          "suggestion": "Defina um response_model usando um modelo Pydantic para a estrutura de resposta (ex: `response_model=UserCountResponse`) ou um tipo Python adequado (ex: `response_model=dict[str, int]`).",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint não especifica explicitamente o 'status_code'. Embora o padrão 200 seja comum, especificá-lo aumenta a clareza e a intenção do código, especialmente para outros status como 201 (Created) ou 204 (No Content).",
          "suggestion": "Adicione 'status_code=200' ao decorador `@router.get` para clareza explícita.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "warning",
          "rule_category": "naming_conventions",
          "check_failed": "Variáveis em snake_case",
          "description": "A variável 'userCount' está em camelCase, o que viola a convenção Python de usar snake_case para nomes de variáveis (ex: 'user_count').",
          "suggestion": "Renomeie 'userCount' para 'user_count'.",
          "line_reference": "Linha 8"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função 'get_user_count' não possui anotação de tipo de retorno, o que dificulta a inferência de tipo e a validação estática do código.",
          "suggestion": "Adicione uma anotação de tipo de retorno, por exemplo, `-> dict[str, int]`.",
          "line_reference": "Linha 6"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 12.24,
        "timestamp": "2026-01-15 23:38:01"
      },
      "file_path": "[GOOD] GOOD_008"
    },
    {
      "overall_status": "fail",
      "overall_score": 84,
      "summary": "O código possui problemas na definição de `response_model`, `status_code` e anotações de tipo de retorno.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint POST /items não define um `response_model` explícito. Isso impede que o OpenAPI gerado documente a estrutura exata da resposta e que o FastAPI valide a saída.",
          "suggestion": "Adicione `response_model=Item` ao decorator `@router.post`.",
          "line_reference": "Linha 9"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint POST /items não especifica um `status_code` explícito. Para operações de criação bem-sucedidas, o `status_code` 201 (Created) é geralmente mais apropriado do que o padrão 200 (OK).",
          "suggestion": "Adicione `status_code=201` ao decorator `@router.post`.",
          "line_reference": "Linha 9"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função `create_item` não possui uma anotação de tipo de retorno. Isso melhora a clareza do código, permite validação estática e ajuda na documentação.",
          "suggestion": "Adicione `-> Item` à assinatura da função: `async def create_item(item: Item) -> Item:`.",
          "line_reference": "Linha 10"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 13.63,
        "timestamp": "2026-01-15 23:38:15"
      },
      "file_path": "[GOOD] GOOD_009"
    },
    {
      "overall_status": "fail",
      "overall_score": 74,
      "summary": "Código possui problemas de estrutura de endpoint, tipagem e recomendações de validação.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint `echo_message` retorna um dicionário, mas não especifica um `response_model`. Isso limita a clareza da documentação OpenAPI e a validação automática da resposta.",
          "suggestion": "Adicione `response_model=dict[str, str]` (ou um Pydantic Model específico) ao decorador `@router.get()`.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O `status_code` padrão 200 OK é usado implicitamente. É uma boa prática declará-lo explicitamente para maior clareza e controle.",
          "suggestion": "Adicione `status_code=200` (ou outro apropriado) ao decorador `@router.get()`.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função `echo_message` não possui uma anotação de tipo de retorno. Isso impede a verificação de tipo estática e a clareza do código.",
          "suggestion": "Adicione `-> dict[str, str]` (ou o tipo de retorno correto) à assinatura da função: `def echo_message(msg: str) -> dict[str, str]:`",
          "line_reference": "Linha 6"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Usa Query(), Path(), Body() para documentação",
          "description": "O parâmetro `msg` é um query parameter implícito. O uso explícito de `Query()` melhora a documentação OpenAPI e permite adicionar validações.",
          "suggestion": "Altere `msg: str` para `msg: str = Query(..., description='A message to echo back')`.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "info",
          "rule_category": "async_usage",
          "check_failed": "Preferência por funções async quando possível",
          "description": "A função `echo_message` é síncrona (`def`). Para endpoints que podem potencialmente envolver operações I/O bloqueantes (mesmo que este seja simples), é preferível usar `async def` para melhor performance em FastAPI.",
          "suggestion": "Mude a assinatura da função para `async def echo_message(...)`.",
          "line_reference": "Linha 6"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Define validações quando necessário"
          ]
        }
      ],
      "_metadata": {
        "response_time": 17.85,
        "timestamp": "2026-01-15 23:38:33"
      },
      "file_path": "[GOOD] GOOD_010"
    },
    {
      "overall_status": "fail",
      "overall_score": 75,
      "summary": "O código possui problemas na estrutura do endpoint, tipagem de retorno e documentação de parâmetros.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint GET '/divide' não especifica um 'response_model' para a resposta de sucesso. Isso impede que o FastAPI gere documentação OpenAPI precisa sobre a estrutura da resposta.",
          "suggestion": "Defina um Pydantic Model (ex: 'class DivisionResult(BaseModel): result: float') e use-o como 'response_model=DivisionResult' no decorador do endpoint.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint GET '/divide' não especifica explicitamente o 'status_code' para a resposta de sucesso (que é 200 por padrão). É uma boa prática defini-lo para clareza e manutenibilidade.",
          "suggestion": "Adicione 'status_code=200' ao decorador '@router.get()'.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função 'divide' não possui anotação de tipo de retorno, o que dificulta a inferência do tipo de dado que a função retorna e pode levar a erros em tempo de desenvolvimento.",
          "suggestion": "Adicione '-> Dict[str, float]' ou um Pydantic Model como tipo de retorno. Ex: 'async def divide(a: int, b: int) -> Dict[str, float]:'.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Usa Query(), Path(), Body() para documentação",
          "description": "Os parâmetros 'a' e 'b' são inferidos como 'Query' parameters, mas não são explicitamente declarados com 'Query()'. Usar 'Query()' melhora a documentação OpenAPI, permite a adição de metadados, validações e valores padrão.",
          "suggestion": "Declare os parâmetros explicitamente como 'a: int = Query(...)' e 'b: int = Query(...)'. Considere 'Query(..., gt=0)' para 'b' se zero não for permitido por padrão.",
          "line_reference": "Linha 6"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 15.69,
        "timestamp": "2026-01-15 23:38:48"
      },
      "file_path": "[GOOD] GOOD_011"
    },
    {
      "overall_status": "fail",
      "overall_score": 68,
      "summary": "O endpoint apresenta deficiências em tratamento de erros, tipagem de retorno e definição de modelos de resposta.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint não especifica um 'response_model' Pydantic. Isso impede a validação automática da resposta e a geração de schema OpenAPI detalhado.",
          "suggestion": "Defina um modelo Pydantic para a saída (ex: UserOut) e adicione 'response_model=UserOut' ao decorador do endpoint.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint não especifica explicitamente um 'status_code'. Embora 200 seja o padrão, a declaração explícita melhora a clareza e a documentação.",
          "suggestion": "Adicione 'status_code=200' (ou outro código HTTP apropriado) ao decorador do endpoint.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função 'get_user' não possui uma anotação de tipo de retorno. Isso dificulta a análise estática e a compreensão do tipo de dado que a função retorna.",
          "suggestion": "Adicione a anotação de tipo de retorno (ex: -> dict ou -> UserOut) à assinatura da função.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Possui try-except para operações críticas",
          "description": "Embora este exemplo retorne um dict estático, em um cenário real, a busca de um usuário por ID (ex: em um banco de dados) é uma operação crítica que pode falhar. Não há tratamento de exceções para essas falhas.",
          "suggestion": "Implemente blocos 'try-except' para tratar potenciais falhas em operações críticas, como acesso a banco de dados ou APIs externas.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Usa HTTPException apropriadamente",
          "description": "Não há tratamento de erros usando HTTPException. Se o usuário não for encontrado, o endpoint deveria retornar um erro 404.",
          "suggestion": "Use 'raise HTTPException(status_code=404, detail=\"User not found\")' para sinalizar erros de recurso não encontrado.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Define status codes corretos para erros",
          "description": "Não há definição explícita de códigos de status para cenários de erro (ex: 404 Not Found se o usuário não existir).",
          "suggestion": "Defina e retorne códigos de status HTTP apropriados para diferentes cenários de erro (ex: 404 para recursos não encontrados, 400 para bad request, 500 para erros internos).",
          "line_reference": "Linha 5"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 12.76,
        "timestamp": "2026-01-15 23:39:01"
      },
      "file_path": "[GOOD] GOOD_012"
    },
    {
      "overall_status": "fail",
      "overall_score": 89,
      "summary": "O código possui algumas melhorias de tipagem e explicitação de status codes, mas está em boa parte aderente às regras.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint não define um status_code explícito para sucesso. Embora o padrão seja 200 OK, explicitá-lo melhora a clareza e manutenção do contrato da API, especialmente para ferramentas de documentação e clientes.",
          "suggestion": "Adicione `status_code=200` ao decorador `@router.get` para documentar explicitamente o retorno em caso de sucesso. Ex: `@router.get(\"/tags\", response_model=List[str], status_code=200)`.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função `get_tags` não possui anotação de tipo de retorno explícita (`-> List[str]`). Embora `response_model` auxilie o FastAPI para documentação e validação de saída, a anotação de tipo na assinatura da função é crucial para ferramentas de análise estática de código Python (como MyPy) e para a clareza do código para outros desenvolvedores.",
          "suggestion": "Adicione `-> List[str]` à assinatura da função: `async def get_tags() -> List[str]:`.",
          "line_reference": "Linha 7"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Define response_model",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 15.97,
        "timestamp": "2026-01-15 23:39:17"
      },
      "file_path": "[GOOD] GOOD_013"
    },
    {
      "overall_status": "fail",
      "overall_score": 40,
      "summary": "O código possui problemas estruturais e de tipagem que devem ser corrigidos.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint GET /ping não define explicitamente um 'response_model'. Isso impede a geração automática de esquemas de resposta no OpenAPI (Swagger UI) e dificulta a validação da estrutura da resposta, o que é uma boa prática para APIs REST.",
          "suggestion": "Defina um Pydantic Model para a resposta esperada e adicione 'response_model=SeuModeloDeResposta' ao decorador @router.get(). Ex: class PingResponse(BaseModel): ping: str; @router.get(..., response_model=PingResponse).",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função 'ping' não possui anotação de tipo de retorno. Isso reduz a clareza do código e a capacidade das ferramentas de análise estática de detectar erros de tipo.",
          "suggestion": "Adicione uma anotação de tipo de retorno à função, indicando o tipo de dado que ela retorna. Ex: 'async def ping() -> Dict[str, str]:'.",
          "line_reference": "Linha 6"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Especifica status_code explicitamente",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 8.89,
        "timestamp": "2026-01-15 23:39:26"
      },
      "file_path": "[GOOD] GOOD_014"
    },
    {
      "overall_status": "fail",
      "overall_score": 74,
      "summary": "O código possui problemas na definição de contratos de API e tratamento de erros.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint '/login-form' não especifica um 'response_model'. Isso dificulta a documentação automática do OpenAPI e a validação da estrutura de resposta.",
          "suggestion": "Defina um Pydantic Model para a resposta esperada e use-o com 'response_model=SeuResponseModel'.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O status_code de sucesso (200) não está explicitamente definido. Embora seja o padrão, a especificação explícita melhora a clareza e a documentação.",
          "suggestion": "Adicione 'status_code=200' ao decorador @router.post() para clareza.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função 'login_form' não possui uma anotação de tipo de retorno, o que prejudica a legibilidade e a análise estática do código.",
          "suggestion": "Adicione uma anotação de tipo de retorno, por exemplo, '-> Dict[str, str]', à assinatura da função.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Usa HTTPException apropriadamente",
          "description": "Não há tratamento de erro explícito para um cenário de falha de login (ex: credenciais inválidas). Atualmente, o endpoint sempre retorna sucesso (HTTP 200) mesmo que a lógica de autenticação falhasse.",
          "suggestion": "Implemente a lógica de autenticação e, em caso de falha, levante uma 'HTTPException' com um 'status_code' apropriado, como 'HTTPStatus.UNAUTHORIZED' (401).",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Define status codes corretos para erros",
          "description": "O endpoint não define explicitamente os status codes para cenários de erro (ex: 401 para credenciais inválidas).",
          "suggestion": "Use 'HTTPException' com status codes HTTP apropriados para diferentes tipos de erro. Considere documentar esses status codes no decorador do endpoint usando o parâmetro 'responses'.",
          "line_reference": "Linha 6"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 14.18,
        "timestamp": "2026-01-15 23:39:40"
      },
      "file_path": "[GOOD] GOOD_015"
    },
    {
      "overall_status": "fail",
      "overall_score": 55,
      "summary": "O código possui problemas críticos de estrutura e tratamento de erros, exigindo atenção imediata.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint GET /customers não define um response_model. Isso impede que o FastAPI gere a documentação OpenAPI completa e precisa do esquema de resposta e pode dificultar a validação da saída.",
          "suggestion": "Defina um modelo Pydantic para a resposta (ex: List[CustomerSchema]) e adicione-o ao decorador: `@router.get('/customers', response_model=List[CustomerSchema], ...)`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função `get_customers` não especifica o tipo de retorno. Isso reduz a clareza do código e a capacidade de ferramentas de análise estática identificarem problemas de tipo.",
          "suggestion": "Adicione a anotação de tipo de retorno, por exemplo: `async def get_customers(...) -> List[CustomerSchema]:`.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Possui try-except para operações críticas",
          "description": "O bloco `except Exception as e:` é muito genérico. Capturar todas as exceções pode mascarar erros inesperados, dificultando a depuração e o entendimento de falhas específicas. Idealmente, exceções específicas devem ser tratadas.",
          "suggestion": "Capture exceções mais específicas (ex: `sqlalchemy.exc.NoResultFound`, `sqlalchemy.exc.IntegrityError`, `sqlalchemy.exc.DatabaseError`) e forneça respostas HTTP mais contextuais, como 404 para 'não encontrado' ou 400 para 'dados inválidos'.",
          "line_reference": "Linha 9"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Especifica status_code explicitamente",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Query(), Path(), Body() para documentação"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 14.77,
        "timestamp": "2026-01-15 23:39:55"
      },
      "file_path": "[MEDIUM] MED_001"
    },
    {
      "overall_status": "fail",
      "overall_score": 58,
      "summary": "Código possui múltiplos problemas estruturais, de tipagem e convenções, impactando a manutenibilidade e documentação.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint não define um 'response_model' utilizando Pydantic. Isso impede a validação automática da resposta e a geração de documentação Swagger/OpenAPI precisa para o formato de saída.",
          "suggestion": "Defina um modelo Pydantic para o usuário (ex: `UserSchema`) e adicione `response_model=UserSchema` ao decorador `@app.get`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O status code de sucesso (200 OK) não foi explicitamente definido no decorador do endpoint. Embora 200 seja o padrão, explicitá-lo melhora a clareza e a legibilidade da API.",
          "suggestion": "Adicione `status_code=200` ao decorador `@app.get`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint não possui tags para organização, o que dificulta a navegação na documentação Swagger UI e a categorização lógica das rotas em projetos maiores.",
          "suggestion": "Adicione `tags=['Users']` (ou uma tag apropriada) ao decorador `@app.get`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Usa APIRouter ao invés de FastAPI app",
          "description": "O código usa `app = FastAPI()` diretamente para definir rotas. Em projetos maiores, é recomendado usar `APIRouter` para modularizar e organizar os endpoints, facilitando a escalabilidade e a separação de responsabilidades.",
          "suggestion": "Crie uma instância de `APIRouter` (ex: `router = APIRouter()`) e registre-o com o `app` principal. Mude `@app.get` para `@router.get`.",
          "line_reference": "Linha 3"
        },
        {
          "severity": "warning",
          "rule_category": "naming_conventions",
          "check_failed": "Nome da função em snake_case com verbo de ação (ex: get_users)",
          "description": "O nome da função `getUserData` está em `camelCase`, o que viola a convenção Python de usar `snake_case` para nomes de funções e métodos. Isso afeta a legibilidade e a consistência do código.",
          "suggestion": "Renomeie a função para `get_user_data`.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Todos parâmetros possuem type hints",
          "description": "O parâmetro `db` não possui uma anotação de tipo explícita. Isso reduz a clareza do código, dificulta a análise estática (linters) e o autocompletar em IDEs, e pode levar a erros de tipo em tempo de execução.",
          "suggestion": "Adicione um type hint para o parâmetro `db`, como `db: Session = Depends(get_db)` (assumindo `Session` é o tipo do objeto de banco de dados).",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função `getUserData` não possui uma anotação de tipo de retorno. Isso dificulta o entendimento do tipo de dado que a função retorna, prejudicando a clareza, a manutenibilidade e a documentação automática.",
          "suggestion": "Adicione um type hint de retorno, por exemplo, `-> UserSchema` (se houver um modelo Pydantic para o usuário) ou `-> User` (se for um modelo ORM).",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Possui try-except para operações críticas",
          "description": "A operação de consulta ao banco de dados (`db.query(...)`) é crítica e pode falhar por diversos motivos (conexão, erros de SQL, etc.). Não há um bloco `try-except` para lidar explicitamente com essas falhas, o que pode levar a erros 500 genéricos sem tratamento específico, dificultando a depuração.",
          "suggestion": "Envolva a operação de banco de dados em um bloco `try-except` para capturar exceções específicas (ex: `SQLAlchemyError`) e retornar um `HTTPException` com uma mensagem e status code mais adequados (ex: 500 Internal Server Error).",
          "line_reference": "Linha 8"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 28.5,
        "timestamp": "2026-01-15 23:40:23"
      },
      "file_path": "[MEDIUM] MED_002"
    },
    {
      "overall_status": "fail",
      "overall_score": 50,
      "summary": "Código possui problemas críticos de tratamento de erros e boas práticas em assincronicidade.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Possui try-except para operações críticas",
          "description": "A busca no banco de dados para a fatura não inclui tratamento para o caso de a fatura não ser encontrada. Retornar 'None' pode levar a um retorno 200 OK com um corpo vazio ou 'null', o que é ambíguo.",
          "suggestion": "Adicione um `if not invoice: raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Invoice not found')` após a consulta ao banco de dados.",
          "line_reference": "Linha 14"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Usa HTTPException apropriadamente",
          "description": "Não há uso de HTTPException para lidar com cenários onde a fatura não é encontrada, o que é uma falha comum em APIs REST para sinalizar erros de cliente.",
          "suggestion": "Implemente `raise HTTPException` com `status.HTTP_404_NOT_FOUND` se a fatura não for encontrada.",
          "line_reference": "Linha 14"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Define status codes corretos para erros",
          "description": "Não há definição explícita de status codes para cenários de erro, como 'não encontrado' (404), o que leva a uma resposta 200 OK mesmo quando o recurso não existe.",
          "suggestion": "Use `status.HTTP_404_NOT_FOUND` com `HTTPException` para indicar que o recurso solicitado não existe.",
          "line_reference": "N/A"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Usa Query(), Path(), Body() para documentação",
          "description": "O parâmetro de path `invoice_id` poderia ser explicitamente definido com `Path()` para adicionar metadados de documentação mais ricos (descrição, exemplos) e validação adicional no Swagger/OpenAPI.",
          "suggestion": "Altere `invoice_id: int` para `invoice_id: int = Path(..., description='ID da fatura a ser buscada', gt=0)`.",
          "line_reference": "Linha 11"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Define validações quando necessário",
          "description": "Embora o tipo `int` seja validado, validações adicionais como 'maior que zero' para o `invoice_id` não estão presentes. Isso melhora a robustez da API e evita consultas inválidas ao banco de dados.",
          "suggestion": "Use `Path(..., gt=0)` para `invoice_id` para garantir que o ID seja um número positivo.",
          "line_reference": "Linha 11"
        },
        {
          "severity": "info",
          "rule_category": "async_usage",
          "check_failed": "Preferência por funções async quando possível",
          "description": "A função `get_invoice` é declarada como `async def`, mas realiza uma operação síncrona de I/O (`db.query(...).first()`) diretamente. Isso bloqueia o loop de eventos, anulando os benefícios de assincronicidade e podendo impactar a performance sob alta concorrência.",
          "suggestion": "Para operações síncronas de I/O dentro de funções `async`, use `await run_in_threadpool(db.query(...).first())` (de `fastapi.concurrency`). Idealmente, para uma aplicação nativamente assíncrona, considere usar uma versão assíncrona do driver do banco de dados (ex: `SQLAlchemy AsyncIO`).",
          "line_reference": "Linha 14"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Possui docstring explicativa",
            "Define response_model",
            "Especifica status_code explicitamente",
            "Declara tags para organização",
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Função possui return type annotation",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        }
      ],
      "_metadata": {
        "response_time": 22.7,
        "timestamp": "2026-01-15 23:40:46"
      },
      "file_path": "[MEDIUM] MED_003"
    },
    {
      "overall_status": "fail",
      "overall_score": 68,
      "summary": "O endpoint apresenta problemas de documentação, tipagem e convenções de estrutura de API.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "A função 'risky_op' não possui uma docstring explicativa. Isso prejudica a documentação automática e a compreensão do endpoint.",
          "suggestion": "Adicione uma docstring clara e concisa para descrever a funcionalidade do endpoint.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint 'risky_op' não define um 'response_model'. Isso impede que o OpenAPI gere um esquema de resposta útil.",
          "suggestion": "Defina um Pydantic model para a resposta esperada e use-o com 'response_model=SeuModeloDeResposta'.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O decorador @router.get não especifica um 'status_code' explícito para o sucesso (e.g., 200 OK).",
          "suggestion": "Adicione 'status_code=200' (ou outro código de sucesso apropriado) ao decorador @router.get para clareza e documentação.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint 'risky_op' não possui 'tags' definidas. Tags são cruciais para organizar a documentação Swagger UI e agrupar endpoints relacionados.",
          "suggestion": "Adicione 'tags=[\"NomeDaSuaCategoria\"]' ao decorador @router.get para melhorar a organização da API.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "warning",
          "rule_category": "naming_conventions",
          "check_failed": "Nome da função em snake_case com verbo de ação (ex: get_users)",
          "description": "O nome da função 'risky_op' é um pouco genérico. 'op' (operation) pode ser mais específico.",
          "suggestion": "Renomeie a função para algo mais descritivo e com um verbo de ação claro, como 'perform_risky_operation' ou 'execute_risky_task'.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função 'risky_op' não possui uma anotação de tipo de retorno. Isso dificulta a análise estática de código e a compreensão do que a função retorna em caso de sucesso.",
          "suggestion": "Adicione uma anotação de tipo de retorno à função, e.g., 'async def risky_op() -> SeuTipoDeRetorno'.",
          "line_reference": "Linha 6"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 12.22,
        "timestamp": "2026-01-15 23:40:58"
      },
      "file_path": "[MEDIUM] MED_004"
    },
    {
      "overall_status": "fail",
      "overall_score": 42,
      "summary": "O código apresenta sérios problemas de estrutura de endpoint, tipagem, tratamento de erros e validação de entrada, necessitando de melhorias significativas para atender às boas práticas do FastAPI.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "A função do endpoint 'calculate' não possui uma docstring. Docstrings são essenciais para documentar a funcionalidade, parâmetros e retorno do endpoint.",
          "suggestion": "Adicione uma docstring clara e concisa para a função `calculate` explicando seu propósito e como ela funciona.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint 'calculate' não define um `response_model`. Isso impede a documentação automática precisa do schema de resposta e a validação de saída, além de otimizar a serialização.",
          "suggestion": "Crie um Pydantic Model (ex: `class CalculationResult(BaseModel): sum: int`) e use-o como `response_model` no decorador `@router.get`.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint 'calculate' não especifica explicitamente o `status_code` de sucesso. Embora 200 seja o padrão, explicitá-lo melhora a clareza e a documentação da API.",
          "suggestion": "Adicione `status_code=status.HTTP_200_OK` (importando `status` de `fastapi`) ao decorador `@router.get`.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint 'calculate' não possui `tags` definidas. Tags são importantes para organizar endpoints em grupos lógicos na documentação interativa (Swagger UI/ReDoc).",
          "suggestion": "Adicione `tags=['Calculations']` ou tags mais relevantes ao decorador `@router.get`.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Todos parâmetros possuem type hints",
          "description": "Os parâmetros `x` e `y` na função `calculate` não possuem type hints. Isso reduz a legibilidade, a capacidade de detecção de erros estáticos e impede o aproveitamento total das funcionalidades do FastAPI para validação e documentação.",
          "suggestion": "Adicione type hints aos parâmetros, por exemplo, `x: int, y: int`.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função `calculate` não possui uma anotação de tipo de retorno. Isso dificulta a compreensão do que a função retorna e a validação de saída, além de limitar as ferramentas de análise estática.",
          "suggestion": "Adicione uma anotação de tipo de retorno, por exemplo, `-> dict` ou, preferencialmente, `-> CalculationResult` se um `response_model` Pydantic for usado.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Possui try-except para operações críticas",
          "description": "A conversão de `x` e `y` para `int` pode falhar se os valores não forem numéricos, resultando em um erro 500 não tratado. Não há um bloco `try-except` para capturar `ValueError` ou tratamento adequado via Pydantic.",
          "suggestion": "Use um bloco `try-except ValueError` para capturar erros de conversão de tipo e retorne uma `HTTPException` apropriada com `status.HTTP_400_BAD_REQUEST`, ou utilize `Query(..., type=int)` para validação automática.",
          "line_reference": "Linha 7"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Usa HTTPException apropriadamente",
          "description": "Não há uso de `HTTPException` para sinalizar erros esperados, como parâmetros inválidos. Em caso de falha na conversão de `int`, um erro 500 genérico seria retornado ao invés de um erro específico para o cliente.",
          "suggestion": "Importe `HTTPException` de `fastapi` e use-o dentro de um bloco `except ValueError` para retornar uma resposta de erro estruturada, como `raise HTTPException(status_code=400, detail='Parâmetros x e y devem ser números inteiros')`.",
          "line_reference": "Linha 7"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Define status codes corretos para erros",
          "description": "O endpoint não define status codes específicos para cenários de erro, como entrada inválida. A falta de tratamento de erros leva a um status 500 padrão em caso de falha inesperada, o que não é ideal para a comunicação da API.",
          "suggestion": "Implemente `try-except` para validação de entrada e retorne `HTTPException` com `status_code=status.HTTP_400_BAD_REQUEST` para entradas inválidas, fornecendo um feedback claro ao cliente.",
          "line_reference": "Linha 7"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Usa Query(), Path(), Body() para documentação",
          "description": "Os parâmetros `x` e `y` são definidos sem `Query()`, `Path()` ou `Body()`. Embora o FastAPI infira que são parâmetros de query, usar esses objetos explicitamente melhora a documentação (ex: descrição, exemplos) e permite validações adicionais.",
          "suggestion": "Modifique a assinatura da função para `calculate(x: int = Query(..., description='Primeiro número'), y: int = Query(..., description='Segundo número'))`.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Define validações quando necessário",
          "description": "A validação atual para `x` e `y` é feita manualmente (`int(x)`) e não aproveita as capacidades de validação do Pydantic/FastAPI, que são mais robustas, automáticas e se integram à documentação da API.",
          "suggestion": "Ao usar `x: int = Query(...)` e `y: int = Query(...)`, o FastAPI automaticamente valida que os parâmetros são inteiros. Se forem necessários requisitos mais complexos (ex: mínimo, máximo), estes podem ser definidos nos parâmetros de `Query()`.",
          "line_reference": "Linha 7"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": []
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 27.59,
        "timestamp": "2026-01-15 23:41:26"
      },
      "file_path": "[MEDIUM] MED_005"
    },
    {
      "overall_status": "fail",
      "overall_score": 68,
      "summary": "Código possui problemas de estrutura de endpoint, tipagem e uso incorreto de assincronicidade.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint não define um response_model. Isso impede o FastAPI de gerar documentação OpenAPI detalhada para a estrutura da resposta e não oferece validação automática da saída.",
          "suggestion": "Crie um modelo Pydantic para a resposta (ex: class StatusResponse(BaseModel): status: str) e use-o com response_model=StatusResponse no decorador @router.get.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint não especifica um status_code explícito para sucesso (ex: 200 OK). Embora o padrão seja 200, defini-lo explicitamente melhora a clareza e documentação.",
          "suggestion": "Adicione status_code=200 ao decorador @router.get.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint não declara tags para organização no OpenAPI. Isso dificulta o agrupamento e navegação de endpoints na documentação interativa.",
          "suggestion": "Adicione tags=['Seção Principal'] ao decorador @router.get para categorizar o endpoint.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "A função sleep_route não possui uma docstring explicativa, o que dificulta a compreensão do propósito e funcionamento do endpoint.",
          "suggestion": "Adicione uma docstring clara e concisa para descrever o que o endpoint faz, seus parâmetros e o que retorna.",
          "line_reference": "Linha 7"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função 'sleep_route' não possui uma anotação de tipo de retorno. Isso prejudica a legibilidade do código e o uso de ferramentas de análise estática.",
          "suggestion": "Adicione `-> dict` ou um modelo Pydantic adequado (se você criar um `response_model`) à assinatura da função.",
          "line_reference": "Linha 7"
        },
        {
          "severity": "info",
          "rule_category": "async_usage",
          "check_failed": "Preferência por funções async quando possível",
          "description": "A função `async def sleep_route()` usa `time.sleep(1)`, que é uma chamada síncrona de bloqueio. Isso bloqueia o loop de eventos do FastAPI, impedindo que outras requisições sejam processadas concorrentemente durante o 'sleep'.",
          "suggestion": "Substitua `time.sleep(1)` por `await asyncio.sleep(1)` para garantir que a operação seja não-bloqueante e aproveite a assincronicidade do FastAPI. Certifique-se de importar `asyncio`.",
          "line_reference": "Linha 8"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        }
      ],
      "_metadata": {
        "response_time": 24.35,
        "timestamp": "2026-01-15 23:41:50"
      },
      "file_path": "[MEDIUM] MED_006"
    },
    {
      "overall_status": "fail",
      "overall_score": 68,
      "summary": "O endpoint possui problemas de estrutura e falta de tipagem de retorno.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "A função 'get_data' não possui uma docstring explicando sua funcionalidade, parâmetros e retorno. Isso dificulta a compreensão e manutenção do código.",
          "suggestion": "Adicione uma docstring clara e concisa para documentar o endpoint, por exemplo, usando o formato Sphinx ou Google style.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint '/data' não define um 'response_model'. Isso impede o FastAPI de gerar documentação de esquema de resposta precisa na OpenAPI/Swagger UI e de realizar validação de saída.",
          "suggestion": "Defina um Pydantic Model para a estrutura de resposta (ex: `class DataResponse(BaseModel): a: int; b: int; c: List[int]`) e utilize-o como 'response_model' no decorador do endpoint (ex: `@router.get('/data', response_model=DataResponse)`).",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint não especifica um 'status_code' explicitamente para o sucesso. Embora 200 seja o padrão, explicitá-lo melhora a clareza, a legibilidade e a intenção do código.",
          "suggestion": "Adicione `status_code=200` (ou o código HTTP apropriado para sucesso, como `status.HTTP_200_OK` do `fastapi.status`) ao decorador do endpoint (ex: `@router.get('/data', status_code=200)`).",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint não possui 'tags' para organização na documentação OpenAPI/Swagger UI. Isso pode dificultar a navegação e o agrupamento de endpoints em APIs maiores.",
          "suggestion": "Adicione `tags=['NomeDaSuaCategoria']` (ex: `tags=['Dados']`) ao decorador do endpoint para agrupá-lo na documentação.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função 'get_data' não possui uma anotação de tipo de retorno. Isso dificulta a análise estática do código, a compreensão do que a função retorna e a integração com outras partes do sistema.",
          "suggestion": "Adicione uma anotação de tipo de retorno clara à assinatura da função, por exemplo, `-> dict` ou, preferencialmente, `-> DataResponse` (se você definir um Pydantic model).",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Usa tipos adequados (List, Dict, Optional, etc)",
          "description": "A função 'get_data' retorna um dicionário complexo, mas a falta de anotação de tipo de retorno impede a especificação detalhada dos tipos internos (chaves e valores). Isso compromete a clareza e a validação do esquema de dados.",
          "suggestion": "Em vez de um dicionário genérico, defina um Pydantic Model (`DataResponse`) para estruturar a resposta, ou utilize tipos detalhados do módulo `typing` (ex: `-> Dict[str, Union[int, List[int]]])` na anotação de retorno.",
          "line_reference": "Linha 6"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 23.31,
        "timestamp": "2026-01-15 23:42:14"
      },
      "file_path": "[MEDIUM] MED_007"
    },
    {
      "overall_status": "fail",
      "overall_score": 58,
      "summary": "O endpoint possui problemas de estrutura, falta de tipagem e convenções.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Usa APIRouter ao invés de FastAPI app",
          "description": "O endpoint é definido diretamente no objeto `FastAPI` (app). Isso dificulta a modularização e a organização da API em projetos maiores, tornando-a menos escalável.",
          "suggestion": "Prefira usar `fastapi.APIRouter` para agrupar endpoints relacionados. Ex: `router = APIRouter(prefix='/my-prefix', tags=['MyModule'])` e depois `router.get(...)`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "A função do endpoint `direct_route` não possui uma docstring. Docstrings são essenciais para documentar a funcionalidade do endpoint, tanto para o desenvolvedor quanto para a geração automática de documentação.",
          "suggestion": "Adicione uma docstring clara e concisa que descreva o propósito, os parâmetros e o retorno do endpoint. Ex: `def direct_route():\n    \"\"\"Retorna uma string simples para verificar o status.\"\"\"`.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint `direct_route` não define um `response_model`. Isso impede que a documentação OpenAPI gerada seja precisa sobre a estrutura esperada da resposta, dificultando o consumo por clientes.",
          "suggestion": "Defina um Pydantic `response_model` para o endpoint, mesmo para respostas simples, para garantir a consistência e a documentação correta. Ex: `@app.get('/direct', response_model=str)`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint `direct_route` não especifica explicitamente o `status_code`. Embora o padrão seja 200 para GETs bem-sucedidos, é uma boa prática ser explícito para clareza e manutenção do código.",
          "suggestion": "Defina o `status_code` explicitamente no decorador do endpoint. Ex: `@app.get('/direct', status_code=200)`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint `direct_route` não possui tags definidas. Tags são cruciais para organizar a documentação Swagger UI, agrupando endpoints relacionados em categorias lógicas.",
          "suggestion": "Adicione tags ao decorador do endpoint ou ao `APIRouter`. Ex: `@app.get('/direct', tags=['Status', 'HealthCheck'])`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "warning",
          "rule_category": "naming_conventions",
          "check_failed": "Nome da função em snake_case com verbo de ação (ex: get_users)",
          "description": "O nome da função `direct_route` é um pouco genérico e não expressa claramente a ação ou o recurso que está sendo manipulado. 'direct' não atua como um verbo de ação claro aqui, e 'route' é um substantivo.",
          "suggestion": "Renomeie a função para um nome mais descritivo que inclua um verbo de ação. Ex: `get_status`, `check_health`, ou `get_direct_route` se 'direct' for um conceito específico.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função `direct_route` não possui uma anotação de tipo de retorno. As anotações de tipo são importantes para a legibilidade do código, validação estática e para que o FastAPI possa inferir o `response_model` automaticamente em alguns casos.",
          "suggestion": "Adicione uma anotação de tipo para o valor de retorno da função. Ex: `def direct_route() -> str:`.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "info",
          "rule_category": "async_usage",
          "check_failed": "Preferência por funções async quando possível",
          "description": "A função `direct_route` é síncrona (`def`) quando poderia ser assíncrona (`async def`). Em FastAPI, é geralmente preferível usar `async def` para endpoints para aproveitar ao máximo o modelo de concorrência assíncrona, a menos que haja um bloqueio I/O pesado que necessite ser executado em um thread pool separado.",
          "suggestion": "Considere tornar a função assíncrona, usando `async def direct_route():`. Isso alinha-se melhor com o modelo de concorrência assíncrona do FastAPI.",
          "line_reference": "Linha 6"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        }
      ],
      "_metadata": {
        "response_time": 25.1,
        "timestamp": "2026-01-15 23:42:39"
      },
      "file_path": "[MEDIUM] MED_008"
    },
    {
      "overall_status": "fail",
      "overall_score": 20,
      "summary": "O código possui diversos problemas estruturais e de tratamento de erros críticos para uma API REST.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "O endpoint `check` não possui uma docstring explicativa, o que dificulta a compreensão da sua funcionalidade e o uso por outros desenvolvedores.",
          "suggestion": "Adicione uma docstring clara e concisa para descrever o propósito do endpoint, seus parâmetros e o que ele retorna.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint `check` não define um `response_model`. Isso prejudica a documentação automática (OpenAPI/Swagger UI) e a validação do formato de saída.",
          "suggestion": "Defina um Pydantic `response_model` para o retorno bem-sucedido e, opcionalmente, para os erros, garantindo um contrato de API claro e validado.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint `check` não especifica o `status_code` explicitamente para o sucesso (o padrão é 200 OK) e usa 200 OK para uma condição de erro, o que é enganoso.",
          "suggestion": "Use o argumento `status_code=200` (ou outro apropriado) no decorador `@router.get` para sucesso, e `HTTPException` com o `status_code` correto (ex: 400 Bad Request) para erros.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint `check` não declara `tags` para organização na documentação OpenAPI/Swagger UI, dificultando a navegação em APIs maiores.",
          "suggestion": "Adicione `tags=['NomeDaRota']` ao decorador do endpoint para categorizá-lo e melhorar a navegabilidade da documentação.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "warning",
          "rule_category": "naming_conventions",
          "check_failed": "Nome da função em snake_case com verbo de ação (ex: get_users)",
          "description": "O nome da função `check` é um pouco genérico e pode não expressar totalmente a intenção da operação que está sendo realizada.",
          "suggestion": "Renomeie a função para algo mais específico, como `get_id_status` ou `validate_id`, para maior clareza e conformidade com convenções.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função `check` não possui anotação de tipo de retorno, o que diminui a clareza do código e a capacidade de detecção de erros estáticos por ferramentas como MyPy.",
          "suggestion": "Adicione uma anotação de tipo de retorno, como `-> dict` ou, preferencialmente, um modelo Pydantic para a resposta (ex: `-> IdResponse`), para melhorar a legibilidade e a verificabilidade do código.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Usa HTTPException apropriadamente",
          "description": "A validação `id < 0` retorna um dicionário de erro com status 200 OK. Isso é inadequado e confunde clientes da API, pois um status 200 implica sucesso.",
          "suggestion": "Utilize `raise HTTPException(status_code=400, detail='Invalid ID')` para sinalizar erros de requisição de forma padronizada e com o status HTTP correto.",
          "line_reference": "Linha 7"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Define status codes corretos para erros",
          "description": "O endpoint retorna um status HTTP 200 (OK) para uma situação de erro (ID inválido), o que é semanticamente incorreto e não comunica o problema adequadamente.",
          "suggestion": "Em vez de retornar 200 OK, utilize `HTTPException` com um status code de erro apropriado, como 400 Bad Request (para entrada inválida), para comunicar o problema ao cliente da API.",
          "line_reference": "Linha 7"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Usa Query(), Path(), Body() para documentação",
          "description": "O parâmetro de caminho `id` não utiliza `Path()` explicitamente para adicionar validações mais avançadas, como valor mínimo, ou metadados adicionais à documentação.",
          "suggestion": "Considere usar `id: int = Path(..., ge=0, description='ID do item')` para validação e documentação mais ricas diretamente na assinatura da função.",
          "line_reference": "Linha 5"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 30.25,
        "timestamp": "2026-01-15 23:43:09"
      },
      "file_path": "[MEDIUM] MED_009"
    },
    {
      "overall_status": "fail",
      "overall_score": 43,
      "summary": "O código possui diversas violações de boas práticas e estrutura de endpoint em FastAPI.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "O endpoint 'process_data' não possui uma docstring explicando sua funcionalidade, parâmetros e retorno. Isso dificulta o entendimento e a manutenção do código.",
          "suggestion": "Adicione uma docstring clara e concisa para melhorar a documentação e legibilidade do código, seguindo os padrões como o reStructuredText ou Google style.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint não define um 'response_model', o que impede o FastAPI de gerar documentação OpenAPI precisa para a resposta e de validar o formato dos dados de retorno.",
          "suggestion": "Defina um Pydantic model para tipar a estrutura da resposta e use-o no decorador: `@router.post(..., response_model=SeuResponseModel)`.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "Para uma operação POST, o status code 200 OK é o padrão em FastAPI. No entanto, o ideal é especificar explicitamente o status_code (e.g., 200 OK ou 201 Created) para maior clareza e aderência às semânticas HTTP.",
          "suggestion": "Adicione 'status_code=200' ou 'status_code=201' (se houver criação de recurso) ao decorador: `@router.post(..., status_code=200)`.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint 'process_data' não possui tags, o que dificulta a organização e categorização da documentação gerada pelo Swagger UI, tornando a navegação menos intuitiva.",
          "suggestion": "Adicione uma lista de tags relevantes ao decorador: `@router.post(..., tags=['Processamento de Dados'])`.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função 'process_data' não possui anotação para o tipo de retorno, o que diminui a clareza do código, dificulta a análise estática e a manutenção.",
          "suggestion": "Adicione o tipo de retorno esperado à assinatura da função: `async def process_data(data: dict) -> dict:` ou `-> SeuResponseModel:`.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Usa HTTPException apropriadamente",
          "description": "O endpoint não implementa tratamento explícito de erros usando HTTPException. Se a lógica complexa falhar, um erro 500 interno genérico será retornado, sem fornecer informações úteis ao cliente.",
          "suggestion": "Implemente blocos `try-except` para a lógica de processamento crítica e levante `HTTPException` com status codes e mensagens claras para erros esperados (ex: `raise HTTPException(status_code=400, detail='Dados inválidos')`).",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Define status codes corretos para erros",
          "description": "Sem tratamento de erros explícito, não há definição de status codes HTTP específicos para cenários de falha. Isso impede que a API comunique problemas de forma padronizada e inteligível para clientes.",
          "suggestion": "Ao levantar `HTTPException`, certifique-se de usar os status codes HTTP apropriados para cada tipo de erro (e.g., 400 Bad Request, 422 Unprocessable Entity, 404 Not Found).",
          "line_reference": "Linha 6"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Usa Pydantic models para body requests",
          "description": "O parâmetro 'data' é tipado como 'dict' para o corpo da requisição. Embora funcional, o uso de Pydantic models é a prática recomendada no FastAPI para validação automática, serialização/desserialização e geração de documentação.",
          "suggestion": "Crie um Pydantic model (ex: `class ProcessDataRequest(BaseModel): ...`) definindo a estrutura esperada e use-o como tipo para 'data': `data: ProcessDataRequest`.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Usa Query(), Path(), Body() para documentação",
          "description": "Embora o FastAPI infira que 'data' é um corpo de requisição, o uso explícito de `Body()` melhora a documentação gerada pelo Swagger UI e permite adicionar metadados, exemplos e validações adicionais.",
          "suggestion": "Altere o parâmetro para `data: dict = Body(...)` ou, preferencialmente, `data: ProcessDataRequest = Body(...)`.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Define validações quando necessário",
          "description": "Como 'data' é um `dict` simples, não há validações explícitas definidas para seus campos internos (e.g., tipos de dados esperados, intervalos de valores, presença de chaves obrigatórias).",
          "suggestion": "Ao usar um Pydantic model, adicione validações aos campos do modelo utilizando `Field()` (ex: `valor: int = Field(..., ge=0, description='Valor deve ser um inteiro positivo')`).",
          "line_reference": "Linha 6"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 42.31,
        "timestamp": "2026-01-15 23:43:51"
      },
      "file_path": "[MEDIUM] MED_010"
    },
    {
      "overall_status": "fail",
      "overall_score": 25,
      "summary": "O endpoint possui problemas de estrutura básica, documentação e tipagem, impactando a clareza e manutenibilidade.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "A função 'get_user_info' não possui uma docstring explicativa. Docstrings são essenciais para documentar a funcionalidade, parâmetros e retorno de um endpoint.",
          "suggestion": "Adicione uma docstring clara e concisa para descrever o propósito do endpoint, como 'Obtém informações básicas do usuário logado.'",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint 'get_user_info' não define um 'response_model'. Isso impede o FastAPI de gerar documentação OpenAPI precisa e realizar validação de saída.",
          "suggestion": "Crie um Pydantic Model (ex: `UserInfoResponse(BaseModel): user: str`) e use-o como `response_model=UserInfoResponse` no decorador `@router.get`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint 'get_user_info' não especifica explicitamente o `status_code` de sucesso (ex: 200 OK). Definir o status code aumenta a clareza e a legibilidade do código.",
          "suggestion": "Adicione `status_code=200` (ou outro apropriado) ao decorador `@router.get`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint 'get_user_info' não declara tags. Tags são cruciais para organizar a documentação Swagger UI, agrupando endpoints relacionados.",
          "suggestion": "Adicione `tags=['users']` (ou tags relevantes) ao decorador `@router.get`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função 'get_user_info' não possui uma anotação de tipo de retorno. Isso dificulta a análise estática do código e a compreensão do que a função retorna.",
          "suggestion": "Adicione a anotação de tipo de retorno, por exemplo, `-> Dict[str, str]` ou, preferencialmente, um Pydantic Model (se `response_model` for implementado).",
          "line_reference": "Linha 5"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 15.24,
        "timestamp": "2026-01-15 23:44:06"
      },
      "file_path": "[MEDIUM] MED_011"
    },
    {
      "overall_status": "fail",
      "overall_score": 47,
      "summary": "Código possui múltiplas violações de boas práticas e uma vulnerabilidade crítica de segurança.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "A função `filter_items` não possui um docstring. Isso prejudica a clareza e a documentação do endpoint.",
          "suggestion": "Adicione um docstring explicando o propósito, parâmetros e o que o endpoint retorna.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint `filter_items` não define um `response_model` usando Pydantic. Isso impede a validação automática da saída e a geração de documentação Swagger/OpenAPI precisa.",
          "suggestion": "Crie um Pydantic Model para a resposta esperada e use-o com `response_model=YourResponseModel`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint `filter_items` não especifica explicitamente o `status_code` de sucesso (ex: `200`). Embora 200 seja o padrão, explicitá-lo melhora a legibilidade e o controle.",
          "suggestion": "Adicione `status_code=status.HTTP_200_OK` ao decorador `@router.get()` (importando `status` de `fastapi`).",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint `filter_items` não possui `tags` definidas. Tags são cruciais para organizar a documentação da API em grupos lógicos no Swagger UI.",
          "suggestion": "Adicione `tags=[\"Items\"]` (ou tag relevante) ao decorador `@router.get()`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função `filter_items` não possui anotação de tipo de retorno. Isso dificulta a inferência de tipo e a validação estática.",
          "suggestion": "Adicione `-> dict` ou um Pydantic model (`-> ItemFilterResponse`) após os parâmetros da função.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Possui try-except para operações críticas",
          "description": "O endpoint usa uma cláusula `WHERE` bruta (`where: str`) diretamente em uma string de consulta SQL, configurando uma vulnerabilidade grave de injeção SQL. Além disso, não há tratamento de exceções (try-except) para erros que podem ocorrer durante a execução da consulta ou devido a entrada maliciosa.",
          "suggestion": "**ALERTA DE SEGURANÇA CRÍTICO**: Nunca construa consultas SQL concatenando strings diretamente de entrada do usuário. Use ORMs (SQLAlchemy), query builders ou prepared statements. Implemente `try-except` para capturar erros de banco de dados e outros problemas.",
          "line_reference": "Linha 8"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Usa HTTPException apropriadamente",
          "description": "Não há uso de `HTTPException` para sinalizar erros de cliente ou servidor (ex: dados inválidos, falha na consulta).",
          "suggestion": "Em caso de falha na validação de entrada (após correção da injeção SQL) ou erros internos, levante `HTTPException` com o `status_code` e `detail` apropriados (importando `HTTPException` de `fastapi`).",
          "line_reference": "Linha 8"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Define status codes corretos para erros",
          "description": "O código não define explicitamente status codes para cenários de erro, como 400 Bad Request para entrada inválida ou 500 Internal Server Error para falhas no servidor.",
          "suggestion": "Use `HTTPException` com `status_code` apropriados (ex: `status.HTTP_400_BAD_REQUEST`, `status.HTTP_500_INTERNAL_SERVER_ERROR`).",
          "line_reference": "Linha 8"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Usa Query(), Path(), Body() para documentação",
          "description": "O parâmetro `where: str` não usa `Query()` para fornecer documentação adicional (descrição, exemplo, validações).",
          "suggestion": "Use `where: str = Query(..., description=\"Cláusula WHERE para filtrar itens\", example=\"category = 'electronics'\")` (importando `Query` de `fastapi`).",
          "line_reference": "Linha 6"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Define validações quando necessário",
          "description": "Este é o problema mais crítico. O parâmetro `where` é uma string recebida diretamente do usuário e usada em uma consulta SQL. Isso representa uma vulnerabilidade direta de injeção SQL, pois não há validação, sanitização ou parametrização para impedir que o usuário insira código SQL malicioso.",
          "suggestion": "**ALERTA DE SEGURANÇA CRÍTICO**: Remodelar a forma como os filtros são passados. Em vez de uma string bruta, use parâmetros de consulta específicos (ex: `category: str`, `min_price: float`). Use Pydantic models para validação estruturada dos filtros e aplique-os através de um ORM ou consultas parametrizadas seguras. Nunca passe SQL raw de entrada do usuário para o banco de dados.",
          "line_reference": "Linha 6"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 30.63,
        "timestamp": "2026-01-15 23:44:37"
      },
      "file_path": "[MEDIUM] MED_012"
    },
    {
      "overall_status": "fail",
      "overall_score": 74,
      "summary": "O endpoint carece de documentação, definição explícita de resposta, status e tags, além de não ter anotação de tipo de retorno.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "A função 'db_test' não possui uma docstring explicativa. Docstrings são cruciais para a documentação e compreensão do código do endpoint, facilitando a manutenção e colaboração.",
          "suggestion": "Adicione uma docstring clara e concisa à função 'db_test' descrevendo sua finalidade, o que ela faz e o formato de seu retorno.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint não define um 'response_model' utilizando um modelo Pydantic. Isso impede o FastAPI de gerar documentação OpenAPI detalhada (ex: no Swagger UI) e de realizar validação de saída, o que pode levar a inconsistências na API.",
          "suggestion": "Crie um modelo Pydantic (ex: `class DbTestResponse(BaseModel): conn: str`) para a estrutura de resposta e adicione-o ao decorador: `@router.get('/db-test', response_model=DbTestResponse)`.",
          "line_reference": "Linha 4"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint não especifica explicitamente o 'status_code'. Embora o padrão seja 200 (OK) para requisições GET bem-sucedidas, a declaração explícita melhora a clareza e a intenção do código, tornando a API mais legível e padronizada.",
          "suggestion": "Adicione 'status_code=200' (ou o código HTTP apropriado) ao decorador do endpoint: `@router.get('/db-test', status_code=200)`.",
          "line_reference": "Linha 4"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint não possui tags para organização. Tags são importantes para agrupar endpoints logicamente na documentação OpenAPI (Swagger UI/ReDoc), facilitando a navegação e o entendimento da API por desenvolvedores.",
          "suggestion": "Adicione 'tags=['Database']' ou uma tag mais apropriada que categorize o endpoint ao decorador: `@router.get('/db-test', tags=['Database'])`.",
          "line_reference": "Linha 4"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função 'db_test' não possui uma anotação de tipo de retorno. A ausência de type hints prejudica a legibilidade do código, a capacidade de manutenção e impede verificações de tipo estáticas eficientes, que são cruciais em bases de código grandes e colaborativas.",
          "suggestion": "Adicione uma anotação de tipo de retorno, como `-> Dict[str, str]` (importando Dict de `typing`) para a função 'db_test'.",
          "line_reference": "Linha 5"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 31.09,
        "timestamp": "2026-01-15 23:45:08"
      },
      "file_path": "[MEDIUM] MED_013"
    },
    {
      "overall_status": "fail",
      "overall_score": 20,
      "summary": "O endpoint apresenta problemas críticos de estrutura, documentação e tipagem, além de uma convenção de nomenclatura não ideal para uma variável mutável global.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "A função do endpoint 'get_count' não possui uma docstring explicativa. Isso prejudica a documentação automática, a clareza do código e a manutenibilidade.",
          "suggestion": "Adicione uma docstring que descreva a funcionalidade do endpoint, seus parâmetros e o que ele retorna (ex: 'Retorna o valor atual do contador, incrementando-o.').",
          "line_reference": "Linha 7"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint 'get_count' não define um 'response_model' com Pydantic. Isso impede que o OpenAPI gere a estrutura da resposta e não valida o tipo de saída, dificultando o consumo da API e a garantia de contrato.",
          "suggestion": "Crie um Pydantic Model (ex: `class CountResponse(BaseModel): count: int`) para a resposta e adicione `response_model=CountResponse` ao decorator do endpoint.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint 'get_count' não especifica explicitamente o 'status_code'. Embora o padrão seja 200, é uma boa prática defini-lo para clareza e controle explícito do comportamento da API, especialmente para status de sucesso como 200 OK.",
          "suggestion": "Adicione `status_code=200` (ou outro código apropriado, como `status.HTTP_200_OK` importado de `fastapi`) ao decorator do endpoint para clareza.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint 'get_count' não declara 'tags'. Tags são essenciais para organizar a documentação Swagger UI, agrupando endpoints relacionados e melhorando a navegabilidade da API.",
          "suggestion": "Adicione `tags=['Counters']` (ou tags mais relevantes como ['Contador', 'Estatísticas']) ao decorator do endpoint para categorização.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "warning",
          "rule_category": "naming_conventions",
          "check_failed": "Variáveis em snake_case",
          "description": "A variável global 'COUNTER' é modificada dentro do endpoint, mas está nomeada em CAPITAL_SNAKE_CASE, que é a convenção para constantes imutáveis. Variáveis mutáveis devem seguir snake_case. Além disso, o uso de estado global mutável em um ambiente assíncrono pode levar a race conditions sem proteção adequada.",
          "suggestion": "Renomeie 'COUNTER' para 'counter'. Considere encapsular o contador em um objeto (ex: `class Counter: value: int`) ou usar uma abordagem thread-safe/async-safe para estados globais se o aplicativo for executado com múltiplos workers/threads (ex: `asyncio.Lock` ou `threading.Lock`).",
          "line_reference": "Linha 3"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função 'get_count' não possui uma anotação de tipo de retorno. Isso dificulta a leitura do código, a verificação estática por ferramentas como MyPy e o entendimento da estrutura da resposta esperada.",
          "suggestion": "Adicione `-> Dict[str, int]` ou, preferencialmente, o Pydantic Model criado para o `response_model` (ex: `-> CountResponse`) à assinatura da função.",
          "line_reference": "Linha 7"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 24.36,
        "timestamp": "2026-01-15 23:45:33"
      },
      "file_path": "[MEDIUM] MED_014"
    },
    {
      "overall_status": "fail",
      "overall_score": 58,
      "summary": "O endpoint possui problemas de estrutura básica, falta de documentação e validação de entrada de dados insuficiente.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "A função do endpoint 'submit' não possui uma docstring explicativa. Isso prejudica a clareza e a documentação automática da API.",
          "suggestion": "Adicione uma docstring explicando a finalidade do endpoint, parâmetros e o que ele retorna.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint 'submit' não define um 'response_model' para especificar o formato da resposta. Isso impede a validação automática da saída e a geração de documentação Swagger/OpenAPI precisa.",
          "suggestion": "Crie um Pydantic Model para a resposta (ex: `class SubmitResponse(BaseModel): received: bool`) e use-o em `response_model=SubmitResponse`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint 'submit' não especifica explicitamente o 'status_code' de sucesso (ex: 200 OK ou 201 Created para POST). Isso pode levar a ambiguidades na documentação e no comportamento.",
          "suggestion": "Defina o `status_code` no decorador, por exemplo: `@router.post('/submit', status_code=200)` ou `status_code=201` para criação.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint 'submit' não possui tags definidas. Tags são essenciais para organizar a documentação Swagger/OpenAPI, agrupando endpoints relacionados.",
          "suggestion": "Adicione tags ao decorador do endpoint, por exemplo: `@router.post('/submit', tags=['items', 'submission'])`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função 'submit' não possui uma anotação de tipo de retorno. Isso dificulta a análise estática de código e o entendimento do tipo de dado retornado.",
          "suggestion": "Adicione uma anotação de tipo de retorno, por exemplo: `async def submit(...) -> Dict[str, bool]:` ou preferencialmente `-> SubmitResponse:` se um Pydantic model for usado.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Usa Pydantic models para body requests",
          "description": "O parâmetro 'data' usa um tipo `dict` para o corpo da requisição. Embora funcional, o uso de um Pydantic Model é a forma recomendada no FastAPI para validar e documentar a estrutura de dados esperada, oferecendo validação automática.",
          "suggestion": "Crie um Pydantic Model (ex: `class SubmitData(BaseModel): ...`) e use-o como tipo para o parâmetro `data: SubmitData`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Usa Query(), Path(), Body() para documentação",
          "description": "O parâmetro 'data' é um corpo de requisição, mas não usa `fastapi.Body()`. Isso impede a adição de metadados de documentação (ex: exemplos, descrição) e validações adicionais.",
          "suggestion": "Use `data: SubmitData = Body(...)` para o corpo da requisição, permitindo documentação e validação detalhadas.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Define validações quando necessário",
          "description": "Ao usar `dict` diretamente para o corpo da requisição, não há validação explícita dos campos esperados. Isso pode levar a erros em tempo de execução se o cliente enviar dados com formato incorreto.",
          "suggestion": "Utilize Pydantic Models com tipos e, se necessário, campos como `Field(..., min_length=...)` para definir validações robustas na entrada de dados.",
          "line_reference": "Linha 5"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "endpoint_structure",
          "checks_passed": [
            "Usa APIRouter ao invés de FastAPI app"
          ]
        },
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "async_usage",
          "checks_passed": [
            "Preferência por funções async quando possível"
          ]
        }
      ],
      "_metadata": {
        "response_time": 21.61,
        "timestamp": "2026-01-15 23:45:54"
      },
      "file_path": "[MEDIUM] MED_015"
    },
    {
      "overall_status": "fail",
      "overall_score": 37,
      "summary": "O código apresenta múltiplas falhas críticas na estrutura do endpoint, tratamento de erros e tipagem.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Usa APIRouter ao invés de FastAPI app",
          "description": "O endpoint está definido diretamente na instância 'app' do FastAPI. Para modularidade e escalabilidade, é fortemente recomendado o uso de APIRouter.",
          "suggestion": "Crie uma instância de APIRouter (ex: `router = APIRouter(prefix='/data', tags=['data'])`) e decore a função com `@router.get('/')`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "A função do endpoint 'get' não possui uma docstring explicativa. Isso prejudica a documentação automática do Swagger/OpenAPI e a legibilidade do código.",
          "suggestion": "Adicione uma docstring clara descrevendo a finalidade do endpoint, parâmetros e o que ele retorna.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint 'get' não define um 'response_model'. Isso impede a validação automática da saída e a geração de esquemas precisos na documentação do Swagger/OpenAPI.",
          "suggestion": "Defina um modelo Pydantic para a resposta (ex: `List[DataOut]`) e use-o no decorador: `@app.get('/data', response_model=List[DataOut])`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint 'get' não especifica explicitamente o `status_code` de sucesso (ex: 200 OK). Embora o padrão seja 200, defini-lo explicitamente melhora a clareza e a documentação.",
          "suggestion": "Adicione `status_code=200` (ou o código apropriado) ao decorador do endpoint: `@app.get('/data', status_code=200)`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint 'get' não declara tags para organização na documentação do Swagger/OpenAPI. Isso dificulta a navegação e agrupamento de endpoints em APIs maiores.",
          "suggestion": "Adicione `tags=['Data']` (ou tags relevantes) ao decorador do endpoint ou ao APIRouter: `@app.get('/data', tags=['Data'])`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "warning",
          "rule_category": "naming_conventions",
          "check_failed": "Nome da função em snake_case com verbo de ação (ex: get_users)",
          "description": "O nome da função 'get' é muito genérico e não indica claramente qual recurso está sendo retornado, prejudicando a legibilidade.",
          "suggestion": "Renomeie a função para algo mais específico, como `get_all_data` ou `list_data`, para refletir a operação e o recurso.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função 'get' não possui anotação de tipo de retorno. Isso diminui a legibilidade, dificulta a análise estática de código e o entendimento do tipo de dados esperado na saída.",
          "suggestion": "Adicione uma anotação de tipo de retorno clara (ex: `-> List[DataSchema]`) para indicar o formato dos dados retornados.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Possui try-except para operações críticas",
          "description": "A operação de banco de dados `db.query(Data).all()` é crítica e não está encapsulada em um bloco `try-except`. Falhas na conexão ou na consulta ao DB não serão tratadas e podem resultar em erros internos do servidor.",
          "suggestion": "Implemente um bloco `try-except` para capturar exceções de banco de dados e retornar `HTTPException`s apropriadas (ex: 500 Internal Server Error, 404 Not Found).",
          "line_reference": "Linha 7"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Usa HTTPException apropriadamente",
          "description": "Não há uso de `HTTPException` para sinalizar erros de forma padronizada. Isso resulta em respostas de erro genéricas ou vazamento de detalhes internos da aplicação em caso de falha.",
          "suggestion": "Dentro do bloco `except`, use `raise HTTPException(status_code=..., detail=...)` para informar o cliente sobre o erro de forma estruturada.",
          "line_reference": "Linha 7"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Define status codes corretos para erros",
          "description": "O tratamento de erro não define status codes HTTP corretos para diferentes tipos de falhas (ex: 404 Not Found para recurso inexistente, 500 Internal Server Error para problemas no servidor).",
          "suggestion": "Ao levantar `HTTPException`, certifique-se de usar o `status_code` HTTP semanticamente correto para a condição de erro específica (ex: 404 para dados não encontrados, 500 para falhas inesperadas).",
          "line_reference": "Linha 7"
        },
        {
          "severity": "info",
          "rule_category": "async_usage",
          "check_failed": "Preferência por funções async quando possível",
          "description": "A função do endpoint 'get' não é assíncrona (`async def`). Operações de I/O (como consulta a banco de dados) devem ser assíncronas para evitar bloqueio do loop de eventos do FastAPI, especialmente em um ambiente de alto desempenho.",
          "suggestion": "Transforme a função em `async def` e use um driver de banco de dados assíncrono (ex: `SQLAlchemy` com `asyncio`) ou execute a operação de bloqueio em um `ThreadPoolExecutor` (ex: `run_in_threadpool`).",
          "line_reference": "Linha 5"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        }
      ],
      "_metadata": {
        "response_time": 19.61,
        "timestamp": "2026-01-15 23:46:14"
      },
      "file_path": "[POOR] POOR_001"
    },
    {
      "overall_status": "fail",
      "overall_score": 26,
      "summary": "O código possui múltiplos problemas estruturais críticos e violações de boas práticas.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Usa APIRouter ao invés de FastAPI app",
          "description": "O código usa `app = FastAPI()` e `@app.post()` diretamente. Isso dificulta a modularização e organização do projeto, especialmente em aplicações maiores.",
          "suggestion": "Use `APIRouter` para agrupar endpoints relacionados, por exemplo, `router = APIRouter()` e depois `router.post()`. O `FastAPI` principal deve incluir o router via `app.include_router(router)`.",
          "line_reference": "Linha 3"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "O endpoint 'create' não possui uma docstring explicativa. Isso dificulta a compreensão da sua funcionalidade e do que ele espera/retorna, além de não aparecer na documentação OpenAPI.",
          "suggestion": "Adicione uma docstring que descreva o propósito do endpoint, seus parâmetros e o que ele retorna.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint 'create' não especifica um `response_model`. Isso impede a geração automática de documentação clara da estrutura de resposta no Swagger/OpenAPI e não permite a validação da saída.",
          "suggestion": "Defina um Pydantic `response_model` para o retorno do endpoint, por exemplo, `response_model=CreationResponse`, onde `CreationResponse` é um `BaseModel`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint 'create' não especifica explicitamente o `status_code` para uma operação POST bem-sucedida. O padrão 200 OK não é o mais semanticamente correto para criação de recursos, que geralmente usa 201 Created.",
          "suggestion": "Importe `status` de `fastapi` e use `status_code=status.HTTP_201_CREATED` no decorador `@app.post` para indicar a criação de um recurso.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint 'create' não possui tags declaradas. Tags são essenciais para organizar a documentação OpenAPI e agrupar endpoints relacionados, tornando a API mais navegável.",
          "suggestion": "Adicione `tags=['NomeDoRecurso']` ao decorador `@app.post` para categorizar o endpoint, por exemplo, `@app.post('/create', tags=['Items'])`.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Todos parâmetros possuem type hints",
          "description": "O parâmetro `data` na função 'create' não possui um type hint. Isso impede a validação automática de entrada do FastAPI e dificulta o entendimento do tipo esperado pelo endpoint.",
          "suggestion": "Adicione um type hint para o parâmetro `data`, preferencialmente usando um Pydantic Model. Ex: `def create(data: MyDataModel):`.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função 'create' não possui anotação de tipo de retorno. Isso dificulta a inferência do tipo de dado que a função retorna, prejudicando a legibilidade e a análise estática do código.",
          "suggestion": "Adicione uma anotação de tipo de retorno. Ex: `def create(data: MyDataModel) -> Dict[str, str]:` ou defina um `response_model` no decorator.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Possui try-except para operações críticas",
          "description": "As operações de banco de dados (`db.add`, `db.commit`) não estão protegidas por um bloco `try-except`. Falhas nessas operações podem causar crash no servidor, inconsistências no banco de dados e expor detalhes internos ao cliente.",
          "suggestion": "Use um bloco `try-except` para lidar com exceções de banco de dados, incluindo `db.rollback()` em caso de erro, e retorne um erro HTTP apropriado via `HTTPException`.",
          "line_reference": "Linha 8"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Usa HTTPException apropriadamente",
          "description": "Não há uso de `HTTPException` para sinalizar erros HTTP padronizados. Exceções não tratadas resultarão em respostas 500 genéricas sem detalhes úteis para o cliente, dificultando a depuração.",
          "suggestion": "Utilize `raise HTTPException(status_code=..., detail=...)` para erros de validação, recursos não encontrados, conflitos ou outros problemas que o cliente precise tratar.",
          "line_reference": "N/A"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Define status codes corretos para erros",
          "description": "O endpoint não define status codes corretos para cenários de erro. Em caso de falha na criação, o cliente receberá um 500 sem informação adequada sobre a causa raiz do problema.",
          "suggestion": "Implemente tratamento de erros com `HTTPException` e utilize status codes como 400 Bad Request (para validação), 409 Conflict (para recurso duplicado), ou 500 Internal Server Error (para falhas inesperadas).",
          "line_reference": "N/A"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Usa Pydantic models para body requests",
          "description": "O parâmetro `data` não é um modelo Pydantic. Acessar `data['name']` e `data['value']` diretamente não fornece validação automática de dados de entrada, é propenso a `KeyError` e impede a documentação automática.",
          "suggestion": "Crie um modelo Pydantic (ex: `class CreateRequest(BaseModel): name: str; value: Any`) e use-o como parâmetro com type hint: `def create(data: CreateRequest):`.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Usa Query(), Path(), Body() para documentação",
          "description": "O parâmetro `data` não utiliza `Body()` para descrever o corpo da requisição. Isso afeta a geração da documentação OpenAPI, a validação de entrada e a clareza para clientes da API.",
          "suggestion": "Use `data: CreateRequest = Body(...)` para indicar explicitamente que é um corpo de requisição, fornecendo melhor documentação e validação via Pydantic.",
          "line_reference": "Linha 6"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Define validações quando necessário",
          "description": "Não há validações explícitas para os campos 'name' e 'value' antes de serem utilizados. Isso pode levar a erros em tempo de execução se os dados de entrada forem malformados ou ausentes, sem um feedback claro para o cliente.",
          "suggestion": "Ao usar modelos Pydantic, defina tipos, restrições (ex: `min_length`, `max_length`, `Field(..., gt=...)`) e validadores personalizados para garantir a integridade dos dados e um bom UX para o cliente.",
          "line_reference": "Linha 7"
        },
        {
          "severity": "info",
          "rule_category": "async_usage",
          "check_failed": "Preferência por funções async quando possível",
          "description": "A função `create` não é definida como `async def`. Embora o FastAPI possa lidar com funções síncronas em um threadpool, a preferência é por `async def` para endpoints, especialmente para operações de I/O, para permitir um tratamento de requisições mais eficiente e não bloqueante.",
          "suggestion": "Defina a função como `async def create(...)` e garanta que as operações de I/O (como `db.add`, `db.commit`) sejam realizadas de forma assíncrona, utilizando um driver de banco de dados assíncrono (ex: SQLAlchemy com `asyncio`) ou `await` para bibliotecas assíncronas.",
          "line_reference": "Linha 6"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        }
      ],
      "_metadata": {
        "response_time": 35.6,
        "timestamp": "2026-01-15 23:46:49"
      },
      "file_path": "[POOR] POOR_002"
    },
    {
      "overall_status": "fail",
      "overall_score": 5,
      "summary": "O código apresenta sérias violações de boas práticas e estrutura fundamental para FastAPI, com problemas em quase todas as categorias analisadas.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "A função 'UpdateItem' não possui uma docstring. Docstrings são essenciais para descrever a funcionalidade do endpoint, seus parâmetros e o que ele retorna.",
          "suggestion": "Adicione uma docstring explicando a finalidade do endpoint, por exemplo: '\"\"\"Atualiza um item existente no banco de dados.\"\"\"'.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint '/update/{ID}' não especifica um 'response_model' para a resposta. Isso impede a validação automática e a geração de documentação Swagger/OpenAPI precisa.",
          "suggestion": "Defina um Pydantic model (ex: ItemResponse) para a estrutura de dados retornada e use-o no decorador: '@router.put(..., response_model=ItemResponse)'.",
          "line_reference": "Linha 1"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint '/update/{ID}' não especifica um 'status_code' explícito para sucesso. Embora 200 OK seja o padrão, explicitá-lo ou usar 204 No Content (se não houver corpo de resposta) melhora a clareza.",
          "suggestion": "Defina o 'status_code' no decorador, por exemplo: '@router.put(..., status_code=200)'.",
          "line_reference": "Linha 1"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint '/update/{ID}' não possui tags definidas. Tags são importantes para agrupar e organizar endpoints na documentação interativa (Swagger UI), melhorando a navegabilidade.",
          "suggestion": "Adicione tags relevantes no decorador, por exemplo: '@router.put(..., tags=[\"Itens\"])'.",
          "line_reference": "Linha 1"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Usa APIRouter ao invés de FastAPI app",
          "description": "O código usa '@app.put()' diretamente. Isso dificulta a modularização, organização do projeto em arquivos menores e o reuso de rotas.",
          "suggestion": "Use APIRouter para definir suas rotas. Crie uma instância 'router = APIRouter()', defina os endpoints com '@router.put()', e depois inclua o router no aplicativo principal: 'app.include_router(router)'.",
          "line_reference": "Linha 1"
        },
        {
          "severity": "warning",
          "rule_category": "naming_conventions",
          "check_failed": "Nome da função em snake_case com verbo de ação (ex: get_users)",
          "description": "A função 'UpdateItem' está usando PascalCase. Em Python, nomes de funções devem ser em 'snake_case'.",
          "suggestion": "Renomeie a função para 'update_item'.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "warning",
          "rule_category": "naming_conventions",
          "check_failed": "Variáveis em snake_case",
          "description": "As variáveis 'ID', 'NewData' (parâmetros) e 'ITEM' não seguem a convenção 'snake_case' para variáveis em Python.",
          "suggestion": "Renomeie para 'item_id', 'new_data' e 'item' respectivamente.",
          "line_reference": "Linha 2, 3"
        },
        {
          "severity": "warning",
          "rule_category": "naming_conventions",
          "check_failed": "Parâmetros seguem convenção Python",
          "description": "Os parâmetros 'ID' e 'NewData' não seguem a convenção 'snake_case' para parâmetros de função em Python.",
          "suggestion": "Renomeie para 'item_id' e 'new_data'.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Todos parâmetros possuem type hints",
          "description": "Os parâmetros 'ID' e 'NewData' não possuem anotações de tipo. Type hints melhoram a legibilidade, ajudam na detecção de erros em tempo de desenvolvimento e são usadas pelo FastAPI para validação e documentação.",
          "suggestion": "Adicione type hints para os parâmetros, por exemplo: 'def update_item(item_id: int, new_data: dict):'.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função 'UpdateItem' não possui uma anotação de tipo para o seu retorno. Anotações de retorno são importantes para clareza e ferramentas de análise estática.",
          "suggestion": "Adicione uma anotação de retorno, por exemplo: 'def update_item(...) -> ItemSchema:'.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Usa tipos adequados (List, Dict, Optional, etc)",
          "description": "A ausência de type hints impede o uso de tipos adequados para 'NewData', que provavelmente seria um Pydantic model.",
          "suggestion": "Ao adicionar type hints, use tipos específicos do Pydantic ou Python como 'int', 'str', ou um Pydantic model ('ItemUpdate').",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Possui try-except para operações críticas",
          "description": "As operações de banco de dados ('db.query', 'db.commit') são críticas e podem falhar. Não há um bloco 'try-except' para lidar com essas falhas.",
          "suggestion": "Envolva as operações de banco de dados em um bloco 'try-except' para capturar exceções, como 'sqlalchemy.orm.exc.NoResultFound' ou 'sqlalchemy.exc.IntegrityError'.",
          "line_reference": "Linha 3"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Usa HTTPException apropriadamente",
          "description": "Se o item com o ID fornecido não for encontrado, o código falhará com um erro de atributo ou de banco de dados, resultando em um erro 500. Não há tratamento para retornar um 'HTTPException' como '404 Not Found'.",
          "suggestion": "Após tentar obter o item, verifique se ele existe e, caso contrário, levante uma 'HTTPException(status_code=404, detail=\"Item not found\")'.",
          "line_reference": "Linha 3"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Define status codes corretos para erros",
          "description": "A falta de tratamento de erros impede a definição de status codes HTTP específicos para diferentes cenários de falha (e.g., 404 para não encontrado, 400 para dados inválidos).",
          "suggestion": "Ao usar 'HTTPException', certifique-se de que o 'status_code' reflita a natureza do erro.",
          "line_reference": "N/A"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Usa Pydantic models para body requests",
          "description": "O parâmetro 'NewData' é recebido como um tipo genérico, sem um Pydantic model. Isso impede a validação automática, a serialização/desserialização e a geração de esquema na documentação.",
          "suggestion": "Defina um Pydantic model (ex: ItemUpdate) com os campos esperados para a atualização e use-o como tipo do parâmetro: 'new_data: ItemUpdate = Body(...)'.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Usa Query(), Path(), Body() para documentação",
          "description": "Os parâmetros 'ID' e 'NewData' não usam as funções 'Path()' e 'Body()' do FastAPI para fornecer metadados, validação e documentação.",
          "suggestion": "Use 'item_id: int = Path(..., description=\"ID do item a ser atualizado\")' e 'new_data: ItemUpdate = Body(..., description=\"Dados para atualização do item\")'.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Define validações quando necessário",
          "description": "Não há validações explícitas para o 'ID' (e.g., deve ser um número inteiro positivo) ou para os campos dentro de 'NewData'.",
          "suggestion": "Use as capacidades de validação do 'Path()' para 'item_id' (e.g., 'gt=0') e do Pydantic model para 'new_data' (e.g., 'min_length', 'max_value').",
          "line_reference": "Linha 2"
        },
        {
          "severity": "info",
          "rule_category": "async_usage",
          "check_failed": "Preferência por funções async quando possível",
          "description": "A função 'UpdateItem' é síncrona ('def'). Operações de I/O, como interações com banco de dados, são bloqueantes e se beneficiam do uso de 'async def' para não bloquear o loop de eventos do FastAPI, especialmente em um ambiente de alta concorrência.",
          "suggestion": "Se o cliente 'db' (ORM/banco de dados) suportar operações assíncronas (ex: 'asyncpg', 'SQLAlchemy' com 'asyncio'), transforme a função em 'async def' e use 'await' para as chamadas de I/O. Se o cliente for síncrono, execute-o em um executor de thread via 'run_in_threadpool' ou um 'BackgroundTasks'.",
          "line_reference": "Linha 2"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Classes em PascalCase"
          ]
        }
      ],
      "_metadata": {
        "response_time": 32.02,
        "timestamp": "2026-01-15 23:47:21"
      },
      "file_path": "[POOR] POOR_003"
    },
    {
      "overall_status": "fail",
      "overall_score": 33,
      "summary": "Código possui múltiplos problemas estruturais críticos e violações de boas práticas.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Usa APIRouter ao invés de FastAPI app",
          "description": "O endpoint é definido diretamente no objeto `app`. Para modularizar e escalar, é recomendado usar `APIRouter`.",
          "suggestion": "Declare `router = APIRouter()` e use `@router.get()`.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "O endpoint `home` não possui uma docstring que explique sua funcionalidade.",
          "suggestion": "Adicione uma docstring clara e concisa para descrever o propósito do endpoint.",
          "line_reference": "Linha 3"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint não define um `response_model` para o tipo de resposta esperado. Isso prejudica a documentação automática e a validação de saída.",
          "suggestion": "Defina um modelo Pydantic para a resposta e use `response_model=YourResponseModel` no decorator `@app.get()`.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint não especifica explicitamente o `status_code` de sucesso (ex: 200).",
          "suggestion": "Adicione `status_code=status.HTTP_200_OK` ao decorator para clareza e conformidade.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint não possui tags para organização na documentação OpenAPI/Swagger UI.",
          "suggestion": "Adicione `tags=['Home']` ou tags mais relevantes ao decorator para categorizar o endpoint.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "warning",
          "rule_category": "naming_conventions",
          "check_failed": "Nome da função em snake_case com verbo de ação (ex: get_users)",
          "description": "O nome da função `home` é um substantivo e não indica uma ação. Isso pode dificultar o entendimento da funcionalidade do endpoint.",
          "suggestion": "Renomeie a função para incluir um verbo de ação, como `get_home` ou `read_home`.",
          "line_reference": "Linha 3"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função `home` não especifica o tipo de retorno esperado, o que reduz a clareza e o suporte de ferramentas de análise estática.",
          "suggestion": "Adicione `-> str` ou o tipo de retorno correto à assinatura da função.",
          "line_reference": "Linha 3"
        },
        {
          "severity": "info",
          "rule_category": "async_usage",
          "check_failed": "Preferência por funções async quando possível",
          "description": "A função `home` é síncrona (`def`). Para endpoints de I/O-bound (como acesso a banco de dados ou APIs externas), funções assíncronas (`async def`) são geralmente preferíveis no FastAPI para melhor performance e concorrência.",
          "suggestion": "Considere usar `async def home()` para aproveitar ao máximo os recursos assíncronos do FastAPI, especialmente se futuras operações de I/O forem adicionadas.",
          "line_reference": "Linha 3"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        }
      ],
      "_metadata": {
        "response_time": 11.62,
        "timestamp": "2026-01-15 23:47:33"
      },
      "file_path": "[POOR] POOR_004"
    },
    {
      "overall_status": "fail",
      "overall_score": 0,
      "summary": "O código apresenta uma vulnerabilidade de segurança crítica devido ao uso de `eval()` com entrada do usuário, além de falhas significativas na estrutura do endpoint, tratamento de erros e validação de entrada.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Usa APIRouter ao invés de FastAPI app",
          "description": "O código usa @app.post() diretamente. Isso dificulta a modularização e organização do projeto, especialmente em APIs maiores.",
          "suggestion": "Use APIRouter: `router = APIRouter(tags=[\"Calculations\"])` e depois `@router.post(\"/calc\")`.",
          "line_reference": "Linha 1"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "A função `calc` não possui uma docstring explicativa.",
          "suggestion": "Adicione uma docstring que descreva a funcionalidade do endpoint, parâmetros e o que ele retorna.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint `/calc` não define um `response_model` para padronizar a estrutura da resposta e auxiliar na documentação.",
          "suggestion": "Use `response_model=SomePydanticModel` no decorador `@router.post`.",
          "line_reference": "Linha 1"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint `/calc` não especifica explicitamente o `status_code` de sucesso (e.g., 200 OK ou 201 Created).",
          "suggestion": "Adicione `status_code=200` ao decorador do endpoint.",
          "line_reference": "Linha 1"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint `/calc` não declara tags para organização na documentação OpenAPI.",
          "suggestion": "Adicione `tags=[\"Calculations\"]` (ou similar) ao decorador do endpoint.",
          "line_reference": "Linha 1"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função `calc` não possui uma anotação de tipo de retorno.",
          "suggestion": "Adicione `-> Any` (ou o tipo esperado, se souber) à assinatura da função, por exemplo, `def calc(expr: str) -> Any:`.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Possui try-except para operações críticas",
          "description": "A função `eval()` pode levantar exceções (e.g., SyntaxError, NameError, ZeroDivisionError) que não estão sendo tratadas. Isso pode levar a respostas genéricas de erro 500 para o cliente.",
          "suggestion": "Envolva a chamada `eval(expr)` em um bloco `try-except` para capturar exceções esperadas e retornar respostas mais específicas.",
          "line_reference": "Linha 3"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Usa HTTPException apropriadamente",
          "description": "Em caso de falha da expressão em `eval()`, o erro será um 500 genérico. Não é usado `HTTPException` para sinalizar problemas específicos com a entrada.",
          "suggestion": "Dentro do bloco `except`, use `raise HTTPException(status_code=400, detail=\"Expressão inválida\")` para erros de sintaxe ou execução.",
          "line_reference": "Linha 3"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Define status codes corretos para erros",
          "description": "A falta de tratamento de erros significa que exceções não capturadas resultarão em um `status_code` 500, o que não reflete a natureza do erro (e.g., 400 Bad Request para uma expressão inválida).",
          "suggestion": "Implemente tratamento de erros com `HTTPException` para garantir `status_code`s apropriados para diferentes cenários de falha.",
          "line_reference": "Linha 3"
        },
        {
          "severity": "error",
          "rule_category": "input_validation",
          "check_failed": "Define validações quando necessário",
          "description": "O uso da função `eval()` com entrada do usuário (`expr`) representa uma **gravíssima vulnerabilidade de segurança**, permitindo a execução de código arbitrário. Um atacante pode injetar código malicioso que deleta arquivos, acessa informações sensíveis ou compromete o sistema. **Este é um erro crítico e deve ser corrigido imediatamente.**",
          "suggestion": "**NUNCA use `eval()` diretamente com entrada do usuário em um ambiente de produção.** Considere uma alternativa segura, como um parser de expressões matemáticas limitado (ex: `asteval`, `numexpr`, ou implementar um parser simples), ou reprojete a funcionalidade para evitar a necessidade de `eval`. Se estritamente necessário, `eval` deve ser executado em um ambiente sandbox extremamente restrito e controlado, o que geralmente não é trivial.",
          "line_reference": "Linha 3"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Usa Pydantic models para body requests",
          "description": "Para entradas de body que são usadas para operações complexas, é preferível usar um modelo Pydantic (ex: `class Expression(BaseModel): expression: str`) para melhor estruturação e documentação.",
          "suggestion": "Crie um modelo Pydantic como `class Expression(BaseModel): expression: str` e use-o como tipo do parâmetro, por exemplo, `def calc(item: Expression):`.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Usa Query(), Path(), Body() para documentação",
          "description": "O parâmetro `expr: str` não usa `fastapi.Body()` explicitamente, o que poderia melhorar a documentação e permitir configurações adicionais.",
          "suggestion": "Adicione `expr: str = Body(..., example=\"2+2\")` para documentação explícita.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "info",
          "rule_category": "async_usage",
          "check_failed": "Preferência por funções async quando possível",
          "description": "A função `calc` é síncrona (`def`) mas poderia ser definida como assíncrona (`async def`) para seguir a convenção de FastAPI de preferir `async` para endpoints (mesmo que `eval` em si seja síncrono e bloquearia o loop de eventos se não for executado em um `ThreadPoolExecutor`).",
          "suggestion": "Altere a assinatura da função para `async def calc(expr: str):`. Para operações CPU-bound como `eval` (se mantida, o que é desaconselhável), FastAPI moverá automaticamente para um threadpool, mas a declaração `async def` é preferível para endpoints.",
          "line_reference": "Linha 2"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        }
      ],
      "_metadata": {
        "response_time": 31.49,
        "timestamp": "2026-01-15 23:48:05"
      },
      "file_path": "[POOR] POOR_005"
    },
    {
      "overall_status": "fail",
      "overall_score": 25,
      "summary": "O código apresenta múltiplas violações de boas práticas e estrutura fundamental para endpoints FastAPI.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Usa APIRouter ao invés de FastAPI app",
          "description": "A rota é definida usando 'app.add_api_route' diretamente com a instância 'app'. Isso dificulta a modularização e o teste do projeto, contrariando a boa prática de usar APIRouter para organizar endpoints.",
          "suggestion": "Instancie um APIRouter (ex: 'router = APIRouter()') e use 'router.add_api_route()' ou os decoradores '@router.get()', '@router.post()', etc.",
          "line_reference": "Linha 4"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "A função 'my_route' não possui uma docstring explicando seu propósito, parâmetros e o que ela retorna. Isso prejudica a legibilidade e a documentação automática.",
          "suggestion": "Adicione uma docstring clara e concisa para a função 'my_route'.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint não define um 'response_model' (modelo Pydantic) para especificar a estrutura da resposta. Isso impede a validação automática da saída e a geração de documentação Swagger/OpenAPI precisa.",
          "suggestion": "Crie um Pydantic Model para a resposta (ex: 'class Item(BaseModel): a: int') e defina-o no 'response_model' do decorator ou de 'add_api_route'.",
          "line_reference": "Linha 4"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint não especifica um 'status_code' explicitamente. Embora o padrão 200 OK seja assumido, definir o status code de sucesso (ex: 200, 201) melhora a clareza e a documentação da API.",
          "suggestion": "Adicione 'status_code=200' ou outro status apropriado em 'add_api_route' ou no decorator.",
          "line_reference": "Linha 4"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint não possui tags definidas, o que dificulta a organização e categorização de rotas na documentação interativa (Swagger UI/ReDoc), especialmente em APIs maiores.",
          "suggestion": "Adicione 'tags=['Nome da Categoria']' em 'add_api_route' ou no decorator.",
          "line_reference": "Linha 4"
        },
        {
          "severity": "warning",
          "rule_category": "naming_conventions",
          "check_failed": "Nome da função em snake_case com verbo de ação (ex: get_users)",
          "description": "O nome da função 'my_route' é genérico e não expressa claramente a ação ou o recurso que o endpoint manipula.",
          "suggestion": "Renomeie a função para algo mais descritivo, como 'read_weird_item' ou 'get_weird_data', seguindo o padrão 'verbo_recurso'.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Todos parâmetros possuem type hints",
          "description": "O parâmetro 'req' na função 'my_route' não possui uma anotação de tipo (type hint). Isso diminui a clareza do código e impede o FastAPI de realizar validação automática de entrada ou injeção de dependência adequada.",
          "suggestion": "Adicione um type hint para 'req', como 'req: Request' ou 'req: MyPydanticModel', dependendo do propósito.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função 'my_route' não possui uma anotação de tipo de retorno. Isso prejudica a legibilidade, o entendimento do contrato da função e as ferramentas de análise estática.",
          "suggestion": "Adicione um type hint para o retorno da função, por exemplo, '-> Dict[str, int]' ou '-> MyResponseModel'.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Usa HTTPException apropriadamente",
          "description": "Não há tratamento de erros explícito usando 'HTTPException'. Em cenários reais, operações podem falhar (ex: item não encontrado, erro de banco de dados), e a API precisa retornar respostas de erro consistentes.",
          "suggestion": "Implemente blocos 'try-except' para operações críticas e use 'raise HTTPException(status_code=..., detail=...)' para indicar falhas na API.",
          "line_reference": "N/A"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Define status codes corretos para erros",
          "description": "Não há definição de status codes específicos para possíveis cenários de erro. A ausência de tratamento de erros significa que qualquer falha interna resultaria em um status 500 genérico, sem informações úteis para o cliente da API.",
          "suggestion": "Junto com 'HTTPException', defina status codes como 400 (Bad Request), 404 (Not Found), 401 (Unauthorized) ou 403 (Forbidden) conforme a natureza do erro.",
          "line_reference": "N/A"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Usa Pydantic models para body requests",
          "description": "O parâmetro 'req' não é definido como um modelo Pydantic para validação automática do corpo da requisição. Isso impede o FastAPI de validar a entrada automaticamente e gera documentação inconsistente.",
          "suggestion": "Se 'req' for um corpo de requisição, defina um modelo Pydantic (ex: 'class RequestData(BaseModel): ...') e use-o como 'async def my_route(request_data: RequestData):'.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Usa Query(), Path(), Body() para documentação",
          "description": "O parâmetro 'req' não utiliza funções como 'Query()', 'Path()' ou 'Body()' para fornecer validação e documentação explícita para os parâmetros da requisição.",
          "suggestion": "Use 'Query()', 'Path()' ou 'Body()' para declarar parâmetros de rota, query strings ou corpo da requisição, adicionando metadados e validação.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Define validações quando necessário",
          "description": "Não há validações explícitas definidas para a entrada de dados. Sem Pydantic models ou 'Query()', 'Path()', 'Body()' com validações, a API é suscetível a dados malformados.",
          "suggestion": "Garanta que todos os dados de entrada (query parameters, path parameters, request body) sejam validados usando as funcionalidades do Pydantic/FastAPI.",
          "line_reference": "N/A"
        },
        {
          "severity": "info",
          "rule_category": "async_usage",
          "check_failed": "Preferência por funções async quando possível",
          "description": "A função do endpoint 'my_route' é síncrona ('def') mas está sendo usada em um contexto de API que pode se beneficiar de ser assíncrona ('async def'), especialmente para operações I/O bound (mesmo que simples como esta).",
          "suggestion": "Mude a assinatura da função para 'async def my_route(...)'. O FastAPI pode executar funções síncronas em um threadpool, mas a preferência para maximizar o desempenho em I/O é 'async def'.",
          "line_reference": "Linha 2"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas"
          ]
        }
      ],
      "_metadata": {
        "response_time": 18.4,
        "timestamp": "2026-01-15 23:48:23"
      },
      "file_path": "[POOR] POOR_006"
    },
    {
      "overall_status": "fail",
      "overall_score": 5,
      "summary": "Código possui múltiplos problemas estruturais e críticas sérias de tratamento de erros, além de violações de boas práticas do FastAPI.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Usa APIRouter ao invés de FastAPI app",
          "description": "O código usa @app.get() diretamente. Isso dificulta a modularização e organização do projeto, especialmente em APIs maiores. APIRouter é a abordagem recomendada para estruturar APIs FastAPI.",
          "suggestion": "Utilize APIRouter para organizar seus endpoints: crie uma instância de `APIRouter` (ex: `router = APIRouter()`) e registre os endpoints nela (ex: `router.get('/silent')`). Em seguida, inclua este router no seu aplicativo FastAPI principal usando `app.include_router(router)`.",
          "line_reference": "Linha 1"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "A função `silent_error` não possui uma docstring explicativa. Docstrings são cruciais para descrever o propósito, os parâmetros e o retorno de um endpoint, melhorando a manutenibilidade e a documentação gerada pelo FastAPI.",
          "suggestion": "Adicione uma docstring clara e concisa para descrever o que o endpoint faz (ex: 'Endpoint que demonstra tratamento de erro silenciado'), seus parâmetros (se houver) e o que ele retorna.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint `silent_error` não define um `response_model`. Isso prejudica a documentação automática (Swagger UI/ReDoc) e a validação do tipo de retorno, tornando a API menos robusta e mais difícil de consumir.",
          "suggestion": "Defina um Pydantic model (ou um tipo Python simples como `str`) como `response_model` no decorador `@app.get` para descrever a estrutura exata da resposta esperada (ex: `response_model=str`).",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint `silent_error` não especifica um `status_code` explicitamente. Embora o padrão 200 OK seja geralmente adequado para sucesso, especificá-lo aumenta a clareza e permite maior controle sobre os códigos de status retornados em diferentes cenários.",
          "suggestion": "Adicione `status_code=status.HTTP_200_OK` (importando `status` de `fastapi`) ao decorador `@app.get` para definir explicitamente o código de status de sucesso.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint `silent_error` não possui tags definidas. Tags são essenciais para organizar a documentação da API no Swagger UI/ReDoc, agrupando endpoints relacionados em categorias lógicas.",
          "suggestion": "Adicione `tags=['NomeDaSuaTag']` (ex: `tags=['Debugging']`) ao decorador `@app.get` para categorizar o endpoint e melhorar a navegabilidade da documentação da API.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função `silent_error` não declara o tipo de retorno. Anotações de tipo de retorno aumentam a legibilidade do código, permitem a análise estática (linting) e ajudam na geração de documentação.",
          "suggestion": "Adicione uma anotação de tipo de retorno à função, por exemplo, `def silent_error() -> str:`.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Usa HTTPException apropriadamente",
          "description": "O bloco `except: pass` silencia todas as exceções sem nenhum tratamento ou registro. Esta é uma prática extremamente perigosa que esconde erros críticos (como a `ZeroDivisionError` provocada) e impede que a API reporte problemas adequadamente ao cliente ou aos logs.",
          "suggestion": "Evite `except: pass`. Em vez disso, capture exceções específicas, registre o erro para depuração e retorne uma resposta de erro significativa, utilizando `raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail='Internal Server Error')` ou um erro mais específico.",
          "line_reference": "Linha 5"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Define status codes corretos para erros",
          "description": "A função retorna 'ok' com um status 200 mesmo após uma falha interna grave (divisão por zero) que foi silenciada. Isso induz o cliente a acreditar que a operação foi bem-sucedida, o que é um comportamento incorreto e enganoso para uma API.",
          "suggestion": "Assegure que os status codes HTTP reflitam o resultado real da operação. Se um erro ocorrer, um status code da série 5xx (ex: 500 Internal Server Error) é apropriado, acompanhado de uma mensagem de erro clara. Nunca retorne 200 OK para operações que falharam.",
          "line_reference": "Linha 7"
        },
        {
          "severity": "info",
          "rule_category": "async_usage",
          "check_failed": "Preferência por funções async quando possível",
          "description": "A função `silent_error` não é definida como `async def`. Embora a operação interna atual seja síncrona, em um contexto de API web, é uma boa prática considerar `async` para endpoints que possam eventualmente envolver operações I/O que bloqueiam o event loop, a fim de maximizar o throughput.",
          "suggestion": "Considere tornar a função `async def` se ela for ou puder vir a ser I/O-bound. Para operações puramente CPU-bound, se o objetivo é não bloquear o event loop, use `run_in_threadpool` do `starlette.concurrency` ou mantenha-a síncrona se o impacto no throughput for aceitável.",
          "line_reference": "Linha 2"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        }
      ],
      "_metadata": {
        "response_time": 28.87,
        "timestamp": "2026-01-15 23:48:52"
      },
      "file_path": "[POOR] POOR_007"
    },
    {
      "overall_status": "fail",
      "overall_score": 30,
      "summary": "Código possui múltiplos problemas estruturais críticos e de robustez, com falta de tipagem e tratamento de erros.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "A função `get_user_bad` não possui uma docstring explicativa, dificultando o entendimento do seu propósito, parâmetros e o que ela retorna.",
          "suggestion": "Adicione uma docstring (triplas aspas) para descrever a funcionalidade da função, seus parâmetros e o valor de retorno esperado.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint `get_user_bad` não define um `response_model` no decorador. Isso impede a geração de documentação de schema de resposta na OpenAPI (Swagger UI/ReDoc) e a validação automática da saída.",
          "suggestion": "Crie um Pydantic Model que represente a estrutura de dados retornada e defina-o no decorador: `@app.get(..., response_model=SeuModeloDeResposta)`.",
          "line_reference": "Linha 1"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint `get_user_bad` não especifica explicitamente o `status_code` para o sucesso da operação. Embora o padrão seja 200 OK, a explicitação aumenta a clareza e a manutenibilidade do código.",
          "suggestion": "Adicione `status_code=200` (ou o código HTTP de sucesso apropriado) ao decorador do endpoint para documentar explicitamente o resultado esperado.",
          "line_reference": "Linha 1"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint `get_user_bad` não declara `tags` para organização na documentação interativa (Swagger UI/ReDoc). Isso pode dificultar a navegação e o agrupamento de endpoints relacionados.",
          "suggestion": "Adicione `tags=['Users']` (ou tags relevantes) ao decorador do endpoint para categorizá-lo e organizá-lo na documentação.",
          "line_reference": "Linha 1"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Usa APIRouter ao invés de FastAPI app",
          "description": "O código usa `@app.get()` diretamente no objeto `app` da aplicação FastAPI. Em projetos maiores, essa abordagem dificulta a modularização, reuso de rotas e organização do código.",
          "suggestion": "Utilize `fastapi.APIRouter` para agrupar endpoints relacionados em módulos separados e, em seguida, inclua esses roteadores no objeto `app` principal. Ex: `router = APIRouter(prefix='/users', tags=['Users']); @router.get('/{id}')`.",
          "line_reference": "Linha 1"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Todos parâmetros possuem type hints",
          "description": "O parâmetro `id` da função `get_user_bad` não possui um type hint. A ausência de tipagem dificulta a validação automática, a inferência de tipo por IDEs e a clareza do código.",
          "suggestion": "Adicione um type hint para o parâmetro `id` (e.g., `id: int`) para indicar seu tipo esperado.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função `get_user_bad` não possui uma anotação de tipo de retorno. A ausência prejudica a legibilidade do código, a validação de saída e o auto-completar em IDEs.",
          "suggestion": "Adicione uma anotação de tipo de retorno para a função (e.g., `-> dict` ou, preferencialmente, um Pydantic Model que represente a resposta).",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Possui try-except para operações críticas",
          "description": "A operação `db.get(id)` pode falhar (e.g., ID não encontrado, erro de conexão com banco de dados) e não está protegida por um bloco `try-except`. Isso pode levar a erros não tratados e falhas na aplicação.",
          "suggestion": "Envolva operações críticas de I/O e acesso a dados em blocos `try-except` para tratar exceções de forma controlada e retornar respostas HTTP apropriadas.",
          "line_reference": "Linha 3"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Usa HTTPException apropriadamente",
          "description": "Se o usuário com o `id` especificado não for encontrado por `db.get(id)` (retornando `None`), o código tentará acessar `user.name` e `user.password_hash` em um objeto `NoneType`, resultando em um `AttributeError`. Isso não é um erro HTTP 404 claro para o cliente da API.",
          "suggestion": "Verifique se o recurso foi encontrado e, caso contrário, levante uma `fastapi.HTTPException` com o `status_code` apropriado (e.g., `raise HTTPException(status_code=404, detail='User not found')`).",
          "line_reference": "Linha 3"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Define status codes corretos para erros",
          "description": "Não há tratamento explícito para condições de erro, o que significa que status codes HTTP apropriados (como 404 Not Found, 500 Internal Server Error) não são retornados em caso de falha na recuperação do usuário.",
          "suggestion": "Ao levantar exceções (e.g., `HTTPException`), defina o `status_code` correto que reflita a natureza do erro, fornecendo feedback claro ao cliente da API.",
          "line_reference": "Linha 3"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Usa Query(), Path(), Body() para documentação",
          "description": "O parâmetro de rota `id` não utiliza `fastapi.Path()`. Isso impede a adição de validações adicionais ao parâmetro de rota e limita a documentação detalhada na Swagger UI.",
          "suggestion": "Utilize `id: int = Path(...)` para declarar o parâmetro, adicionar validações e incluir metadados como descrição e exemplos.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Define validações quando necessário",
          "description": "Não há validação para o parâmetro `id`. Um ID inválido (e.g., negativo, zero, ou um tipo diferente de inteiro se não for tipado) pode ser passado para a função `db.get()`, levando a comportamento inesperado ou erros.",
          "suggestion": "Adicione validações ao parâmetro `id` usando `Path()` (e.g., `id: int = Path(..., gt=0)` para garantir que o ID seja um inteiro positivo válido).",
          "line_reference": "Linha 2"
        },
        {
          "severity": "info",
          "rule_category": "async_usage",
          "check_failed": "Preferência por funções async quando possível",
          "description": "A função `get_user_bad` é síncrona (`def`). Se a operação `db.get(id)` for uma operação de I/O bloqueante (comum para acesso a banco de dados), ela bloqueará o loop de eventos, prejudicando o desempenho geral da aplicação FastAPI.",
          "suggestion": "Converta a função para `async def` se `db.get()` for uma função awaitable (não-bloqueante). Se `db.get()` for bloqueante, é recomendado executá-la em um thread pool usando `run_in_threadpool` do Starlette (FastAPI faz isso automaticamente para `def` endpoints, mas o uso explícito ou a preferência por drivers assíncronos é melhor).",
          "line_reference": "Linha 2"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests"
          ]
        }
      ],
      "_metadata": {
        "response_time": 38.52,
        "timestamp": "2026-01-15 23:49:30"
      },
      "file_path": "[POOR] POOR_008"
    },
    {
      "overall_status": "fail",
      "overall_score": 47,
      "summary": "Código possui problemas críticos de estrutura, tipagem e desempenho, e viola diversas boas práticas.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Usa APIRouter ao invés de FastAPI app",
          "description": "O endpoint usa o objeto 'app' diretamente. Para projetos maiores e mais organizados, é recomendado usar APIRouter para modularização.",
          "suggestion": "Crie uma instância de APIRouter (e.g., `router = APIRouter(tags=['SuaTag'])`) e use `@router.get`.",
          "line_reference": "Linha 1"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "A função do endpoint não possui uma docstring para explicar sua finalidade, parâmetros e o que ela retorna. Isso prejudica a legibilidade e a manutenção do código.",
          "suggestion": "Adicione uma docstring clara e concisa para descrever o endpoint, como: `\"\"\"Endpoint que intencionalmente bloqueia o event loop.\"\"\"`.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint não define um `response_model` para o retorno. Isso impede que o FastAPI gere automaticamente a documentação OpenAPI correta e não garante o formato de saída dos dados.",
          "suggestion": "Defina um Pydantic model para o tipo de retorno esperado e use `response_model=SeuModeloDeResposta` no decorador `@app.get`.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint não especifica um `status_code` explicitamente para o sucesso da operação. Embora o padrão 200 OK seja implícito, a explicitação melhora a clareza e a intenção.",
          "suggestion": "Adicione `status_code=200` (ou outro código HTTP apropriado) ao decorador `@app.get`.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint não declara tags para organização na documentação OpenAPI. Com o crescimento da API, a falta de tags dificulta a navegação.",
          "suggestion": "Adicione `tags=['NomeDaSuaTag']` ao decorador `@app.get` para agrupar endpoints relacionados.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função do endpoint não possui anotação de tipo de retorno. Isso prejudica a legibilidade, a capacidade de ferramentas de análise estática e a validação em tempo de execução.",
          "suggestion": "Adicione a anotação de tipo de retorno (ex: `def hang() -> dict:` ou `-> SeuModeloDeResposta:`) para clareza e validação.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Possui try-except para operações críticas",
          "description": "A função contém uma operação crítica (`while True: pass`) que bloqueia o event loop sem nenhum tratamento de erro. Isso resultará em um servidor travado para todas as requisições.",
          "suggestion": "Operações de bloqueio nunca devem ser executadas diretamente no event loop. Se for intencional para testes de falha, considere um processo externo. Se for um loop de processamento, use `asyncio.sleep` para ceder o controle ou execute em um `ThreadPoolExecutor`.",
          "line_reference": "Linha 3"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Usa HTTPException apropriadamente",
          "description": "O endpoint não utiliza `HTTPException` para sinalizar erros de forma padronizada. Em caso de falha (ou neste caso, de bloqueio intencional), uma exceção personalizada ou um retorno de erro deveria ser tratado com `HTTPException`.",
          "suggestion": "Para sinalizar problemas, use `raise HTTPException(status_code=500, detail='Server hanging intentionally')`.",
          "line_reference": "Linha 3"
        },
        {
          "severity": "error",
          "rule_category": "error_handling",
          "check_failed": "Define status codes corretos para erros",
          "description": "Não há tratamento de erros ou definição de status codes para cenários de falha. Um endpoint que causa um 'hang' deveria, idealmente, retornar um status 500 (Internal Server Error) ou um código específico se fosse um cenário de teste intencional.",
          "suggestion": "Implemente tratamento de exceções com `try-except` e retorne `HTTPException` com status codes como 500 para erros de servidor.",
          "line_reference": "Linha 3"
        },
        {
          "severity": "info",
          "rule_category": "async_usage",
          "check_failed": "Preferência por funções async quando possível",
          "description": "A função é síncrona (`def`) e contém um loop de bloqueio (`while True: pass`), o que irá travar completamente o event loop do FastAPI e Uvicorn, tornando o servidor indisponível para outras requisições. Para operações de E/S ou de longa duração, `async def` é preferível e o bloqueio deve ser explicitamente gerenciado.",
          "suggestion": "Torne a função assíncrona (`async def hang():`) e NUNCA coloque lógica de bloqueio diretamente. Se uma operação de bloqueio for necessária, use `await asyncio.to_thread(blocking_function)` ou `await run_in_threadpool(blocking_function)`.",
          "line_reference": "Linha 2"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Nome da função em snake_case com verbo de ação (ex: get_users)",
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "type_hints",
          "checks_passed": [
            "Todos parâmetros possuem type hints",
            "Usa tipos adequados (List, Dict, Optional, etc)"
          ]
        },
        {
          "rule_category": "input_validation",
          "checks_passed": [
            "Usa Pydantic models para body requests",
            "Usa Query(), Path(), Body() para documentação",
            "Define validações quando necessário"
          ]
        }
      ],
      "_metadata": {
        "response_time": 18.12,
        "timestamp": "2026-01-15 23:49:48"
      },
      "file_path": "[POOR] POOR_009"
    },
    {
      "overall_status": "fail",
      "overall_score": 8,
      "summary": "Código possui múltiplos problemas estruturais, falta de tipagem e um anti-padrão Python grave.",
      "violations": [
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Usa APIRouter ao invés de FastAPI app",
          "description": "Código usa '@app.get()' diretamente. Isso dificulta a modularização e organização de uma API maior.",
          "suggestion": "Utilize 'APIRouter' para agrupar endpoints e permitir a inclusão em diferentes partes da aplicação: 'router = APIRouter()' e depois 'router.get()'.",
          "line_reference": "Linha 1"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Possui docstring explicativa",
          "description": "A função de endpoint não possui uma docstring que explique sua finalidade, parâmetros e o que ela retorna.",
          "suggestion": "Adicione uma docstring clara e concisa para descrever o endpoint, como ele funciona e o que ele retorna.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Define response_model",
          "description": "O endpoint não define um 'response_model', o que impede o FastAPI de gerar documentação OpenAPI detalhada para a resposta e realizar validação de saída.",
          "suggestion": "Defina um modelo Pydantic para a resposta e use o parâmetro 'response_model' no decorador do endpoint (ex: 'response_model=List[int]').",
          "line_reference": "Linha 1"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Especifica status_code explicitamente",
          "description": "O endpoint não especifica explicitamente o 'status_code' para uma resposta bem-sucedida, usando o padrão 200 OK implicitamente.",
          "suggestion": "Especifique o 'status_code' explicitamente para clareza e controle (ex: 'status_code=status.HTTP_200_OK').",
          "line_reference": "Linha 1"
        },
        {
          "severity": "error",
          "rule_category": "endpoint_structure",
          "check_failed": "Declara tags para organização",
          "description": "O endpoint não declara tags, o que dificulta a organização e categorização na documentação OpenAPI (Swagger UI/ReDoc).",
          "suggestion": "Adicione tags relevantes para organizar o endpoint na documentação (ex: 'tags=[\"ProblemasComuns\"]' ou 'tags=[\"DefaultArgs\"]').",
          "line_reference": "Linha 1"
        },
        {
          "severity": "warning",
          "rule_category": "naming_conventions",
          "check_failed": "Nome da função em snake_case com verbo de ação (ex: get_users)",
          "description": "O nome da função 'bad_defaults' descreve um problema da implementação, mas não a ação clara que o endpoint executa em relação a um recurso. Isso pode gerar confusão sobre a finalidade da rota.",
          "suggestion": "Renomeie a função para um nome que reflita a ação do endpoint sobre um recurso, como 'get_defaults' ou 'list_defaults'. Se a intenção é demonstrar um erro, use um nome que deixe isso claro, mas ainda com um verbo de ação (ex: 'demonstrate_mutable_default').",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Todos parâmetros possuem type hints",
          "description": "O parâmetro 'lista' não possui type hint, o que prejudica a legibilidade, a validação estática de código e a geração de documentação.",
          "suggestion": "Adicione type hint para o parâmetro 'lista' (ex: 'lista: List[int]').",
          "line_reference": "Linha 2"
        },
        {
          "severity": "error",
          "rule_category": "type_hints",
          "check_failed": "Função possui return type annotation",
          "description": "A função 'bad_defaults' não possui uma anotação de tipo de retorno, o que dificulta a compreensão do que a função retorna e a validação estática.",
          "suggestion": "Adicione uma anotação de tipo de retorno para a função (ex: '-> List[int]').",
          "line_reference": "Linha 2"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Define validações quando necessário",
          "description": "O uso de um argumento padrão mutável (lista=[]) é um anti-padrão grave em Python. A cada chamada do endpoint, a mesma lista será modificada, resultando em comportamento imprevisível e vazamento de estado entre requisições.",
          "suggestion": "Nunca use objetos mutáveis como argumentos padrão. Altere para 'lista: Optional[List[int]] = None' e inicialize 'lista = []' dentro da função se 'None' for recebido, ou use 'lista: List[int] = Query([])' para forçar um novo objeto a cada requisição via FastAPI.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "warning",
          "rule_category": "input_validation",
          "check_failed": "Usa Query(), Path(), Body() para documentação",
          "description": "O parâmetro 'lista' é definido como um argumento Python padrão, mas não como um parâmetro de consulta, caminho ou corpo do FastAPI, o que impede que ele seja documentado corretamente na OpenAPI.",
          "suggestion": "Se 'lista' for um parâmetro de consulta, use 'lista: List[int] = Query([])'. Se for um parâmetro de corpo, use um Pydantic Model com 'Body()'.",
          "line_reference": "Linha 2"
        },
        {
          "severity": "info",
          "rule_category": "async_usage",
          "check_failed": "Preferência por funções async quando possível",
          "description": "A função do endpoint é síncrona ('def'). Embora para operações simples e não bloqueantes isso possa ser aceitável, o FastAPI é otimizado para funções assíncronas ('async def') para melhor performance em I/O bound tasks.",
          "suggestion": "Considere tornar a função assíncrona ('async def') para aproveitar ao máximo o desempenho do FastAPI e evitar bloqueios do event loop, mesmo para operações que parecem simples. Se houver CPU-bound tasks, utilize 'run_in_threadpool' do 'fastapi.concurrency'.",
          "line_reference": "Linha 2"
        }
      ],
      "compliant_rules": [
        {
          "rule_category": "naming_conventions",
          "checks_passed": [
            "Variáveis em snake_case",
            "Classes em PascalCase",
            "Parâmetros seguem convenção Python"
          ]
        },
        {
          "rule_category": "error_handling",
          "checks_passed": [
            "Possui try-except para operações críticas",
            "Usa HTTPException apropriadamente",
            "Define status codes corretos para erros"
          ]
        }
      ],
      "_metadata": {
        "response_time": 26.25,
        "timestamp": "2026-01-15 23:50:15"
      },
      "file_path": "[POOR] POOR_010"
    }
  ],
  "timestamp": "2026-01-15 23:50:15",
  "benchmark_metadata": {
    "llm_name": "Gemini 2.5-flash",
    "total_time": 1063.07,
    "dataset_version": "1.0"
  }
}